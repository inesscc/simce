{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Modelo de detecci\u00f3n de dobles marcas SIMCE","text":"<p>La presente documentaci\u00f3n ense\u00f1a c\u00f3mo correr el modelo y su organizaci\u00f3n. </p>"},{"location":"#estructura-del-proyecto","title":"Estructura del proyecto","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"#comandos","title":"Comandos","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"generar_insumos_img/","title":"Generaci\u00f3n de insumos","text":"<p>En este manual se repasan las funciones asociadas a la generaci\u00f3n de insumos utilizados para facilitar el recorte de subpreguntas </p> <p>Created on Thu May 16 17:46:31 2024</p> <p>@author: jeconchao</p>"},{"location":"generar_insumos_img/#simce.generar_insumos_img.calcular_pregunta_actual","title":"<code>calcular_pregunta_actual(pages, p, dic_q)</code>","text":"<p>M\u00e9todo program\u00e1tico para obtener pregunta del cuadernillo que se est\u00e1 procesando. Dado que siempre una p\u00e1gina tiene preguntas que vienen en orden ascendente y la otra en orden descendente (por la l\u00f3gica de cuadernillo), hubo que incorporar esto en el algoritmo</p> <p>Parameters:</p> Name Type Description Default <code>pages</code> <code>tuple[int, int]</code> <p>tupla que contiene la p\u00e1gina izquierda y la p\u00e1gina derecha de la p\u00e1gina del     cuadernillo que se est\u00e1 procesando. Ejemplo: (10,3) para la p\u00e1gina 2 del cuadernillo     estudiantes 2023</p> required <code>p</code> <code>int</code> <p>integer que toma valor 0 \u00f3 1. Si es 0 es la primera p\u00e1gina del cuadernillo, si es  1, es la segunda.</p> required <code>dic_q</code> <code>dict</code> <p>diccionario que contiene dos llaves, q_bajo y q_alto. q_bajo es la pregunta actual desde el lado     bajo y q_alto es la pregunta actual desde el lado alto del cuadernillo.</p> required <p>Returns:</p> Name Type Description <code>q</code> <code>int</code> <p>pregunta actual siendo procesada</p> Source code in <code>simce/generar_insumos_img.py</code> <pre><code>def calcular_pregunta_actual(pages: tuple[int, int], p: int, dic_q: dict)-&gt; int:\n    '''M\u00e9todo program\u00e1tico para obtener pregunta del cuadernillo que se est\u00e1\n    procesando. Dado que siempre una p\u00e1gina tiene preguntas que vienen en orden\n    ascendente y la otra en orden descendente (por la l\u00f3gica de cuadernillo), hubo\n    que incorporar esto en el algoritmo\n\n    Args:\n        pages: tupla que contiene la p\u00e1gina izquierda y la p\u00e1gina derecha de la p\u00e1gina del\n                cuadernillo que se est\u00e1 procesando. Ejemplo: (10,3) para la p\u00e1gina 2 del cuadernillo\n                estudiantes 2023\n\n        p: integer que toma valor 0 \u00f3 1. Si es 0 es la primera p\u00e1gina del cuadernillo, si es  1, es\n            la segunda.\n\n        dic_q: diccionario que contiene dos llaves, q_bajo y q_alto. q_bajo es la pregunta actual desde el lado\n                bajo y q_alto es la pregunta actual desde el lado alto del cuadernillo.\n\n    Returns:\n        q: pregunta actual siendo procesada\n\n    '''\n\n    # si es la p\u00e1g + alta del cuadernillo:\n    if pages[p] &gt; pages[1-p]:\n        dic_q['q_alto'] -= 1\n        return dic_q['q_alto']\n    # si es la p\u00e1g m\u00e1s baja del cuardenillo\n    elif (pages[p] &lt; pages[1-p]) &amp; (pages[p] != 1):\n        dic_q['q_bajo'] += 1\n        return dic_q['q_bajo']\n    else:  # Para la portada\n        return 0\n</code></pre>"},{"location":"generar_insumos_img/#simce.generar_insumos_img.generar_diccionarios_x_pagina","title":"<code>generar_diccionarios_x_pagina(n_pages, n_preguntas, directorio_imagenes, nivel, filter_rbd=None, filter_estudiante=None, ignorar_primera_pagina=True)</code>","text":"<p>Funci\u00f3n similar a get_subpreguntas() en el m\u00f3dulo de procesamiento de im\u00e1genes dise\u00f1ada para obtener todas las preguntas en uno o m\u00e1s cuadernillos espec\u00edficos. Se utiliza para insumar los diccionarios autom\u00e1ticos, en particular, preguntas por p\u00e1gina del cuadernillo y  preguntas por imagen del cuadernillo. </p> <p>Parameters:</p> Name Type Description Default <code>n_pages</code> <code>int</code> <p>n\u00b0 de p\u00e1ginas que tiene el cuestionario</p> required <code>n_preguntas</code> <code>int</code> <p>n\u00b0 de preguntas que tiene el cuestionario</p> required <code>directorio_imagenes</code> <code>PathLike</code> <p>directorio desde el que se recogen im\u00e1genes a procesar</p> required <code>nivel</code> <code>str</code> <p>variable que se utiliza cuando se generan insumos.</p> required <code>filter_rbd</code> <code>None | list | str</code> <p>permite filtrar uno o m\u00e1s RBDs espec\u00edficos y solo realizar la operaci\u00f3n sobre estos.</p> <code>None</code> <code>filter_estudiante</code> <code>None | list | str</code> <p>permite filtrar uno o m\u00e1s estudiantes espec\u00edficos y solo realizar la operaci\u00f3n sobre estos.</p> <code>None</code> <code>ignorar_primera_pagina</code> <code>bool</code> <p>booleano que indica si se debe ignorar la primera p\u00e1gina a la hora de  generar los diccionarios autom\u00e1ticos (en general primera p\u00e1gina contiene ejemplos que debemos ignorar.)</p> <code>True</code> <p>Returns:</p> Name Type Description <code>diccionario_nivel</code> <code>dict</code> <p>diccionario donde las llaves son cada una de las preguntas del cuadernillo y los  valores son el n\u00b0 de p\u00e1gina o imagen que le corresponde, seg\u00fan si nivel es \"p\u00e1gina\" o \"cuadernillo\", respectivamente</p> Source code in <code>simce/generar_insumos_img.py</code> <pre><code>def generar_diccionarios_x_pagina(n_pages: int, n_preguntas:int, directorio_imagenes:os.PathLike,\n                              nivel:str,\n                              filter_rbd:None|list|str=None, filter_estudiante:None|list|str=None,\n                             ignorar_primera_pagina:bool=True)-&gt;dict:\n    '''\n    Funci\u00f3n similar a get_subpreguntas() en el m\u00f3dulo de [procesamiento de im\u00e1genes](proc_imgs.md) dise\u00f1ada para obtener\n    todas las preguntas en uno o m\u00e1s cuadernillos espec\u00edficos.\n    Se utiliza para insumar los diccionarios autom\u00e1ticos, en particular, preguntas por p\u00e1gina del cuadernillo y \n    preguntas por imagen del cuadernillo. \n\n    Args:\n        n_pages: n\u00b0 de p\u00e1ginas que tiene el cuestionario\n\n        n_preguntas: n\u00b0 de preguntas que tiene el cuestionario\n\n        directorio_imagenes: directorio desde el que se recogen im\u00e1genes a procesar\n\n        nivel: variable que se utiliza cuando se generan insumos.\n\n        filter_rbd: permite filtrar uno o m\u00e1s RBDs espec\u00edficos y solo realizar la operaci\u00f3n sobre estos.\n\n        filter_estudiante: permite filtrar uno o m\u00e1s estudiantes espec\u00edficos y solo realizar la operaci\u00f3n sobre estos.\n\n        ignorar_primera_pagina: booleano que indica si se debe ignorar la primera p\u00e1gina a la hora de \n            generar los diccionarios autom\u00e1ticos (en general primera p\u00e1gina contiene ejemplos que debemos ignorar.)\n\n\n\n    Returns:\n        diccionario_nivel: diccionario donde las llaves son cada una de las preguntas del cuadernillo y los \n            valores son el n\u00b0 de p\u00e1gina o imagen que le corresponde, seg\u00fan si nivel es \"p\u00e1gina\" o \"cuadernillo\",\n            respectivamente \n\n    '''\n\n\n    # Si queremos correr funci\u00f3n para rbd espec\u00edfico\n    if filter_rbd:\n\n        # Si queremos correr funci\u00f3n solo para el rbd ingresado\n\n        if isinstance(filter_rbd, str):\n            filter_rbd = [filter_rbd]\n        directorios = [i for i in directorio_imagenes.iterdir() if i.name in filter_rbd]\n    else:\n        directorios = directorio_imagenes.iterdir()\n\n    # Permite armar diccionario con mapeo pregunta -&gt; p\u00e1gina cuadernillo (archivo input)\n    diccionario_nivel = dict()\n\n    for num, rbd in enumerate(directorios):\n        if not filter_estudiante:\n            print('############################')\n            print(rbd)\n            print(num)\n            print('############################')\n\n        estudiantes_rbd = {re.search(f'({regex_estudiante})', str(i)).group(1)\n                           for i in rbd.iterdir()}\n\n        # Si queremos correr funci\u00f3n para un estudiante espec\u00edfico:\n        if filter_estudiante:\n            if isinstance(filter_estudiante, str):\n                filter_estudiante = [filter_estudiante]\n            estudiantes_rbd = {\n                i for i in estudiantes_rbd if i in filter_estudiante}\n\n        for estudiante in estudiantes_rbd:\n\n\n            # p\u00e1ginas del cuardenillo\n            pages = (n_pages, 1)\n\n            dic_q = {\n                # pregunta inicial p\u00e1ginas bajas\n                'q_bajo': 0,\n                # pregunta inicial p\u00e1ginas altas\n                'q_alto': n_preguntas + 1}\n\n\n            # Para cada imagen del cuadernillo de un estudiante (2 p\u00e1g x img):\n            for num_pag, dir_pag in enumerate(sorted(list(rbd.glob(f'{estudiante}*')))):\n                # Creamos directorio para guardar im\u00e1genes\n\n                # Obtenemos p\u00e1ginas del cuadernillo actual:\n                pages = get_paginas_actuales_cuadernillo(num_pag, pages)\n\n                # Obtengo carpeta del rbd y archivo del estudiante a\n                # partir del path:\n                file = dir_pag.parts[-1]\n\n                print(f'{file=}')\n                print(f'{num_pag=}')\n\n                # Creamos directorio si no existe\n\n                # Leemos imagen\n                img_preg = cv2.imread(str(dir_pag), 1)\n                img_crop = proc.recorte_imagen(img_preg, 0, 150, 50, 160)\n                # Eliminamos franjas negras en caso de existir\n                img_sin_franja = proc.eliminar_franjas_negras(img_crop)\n\n                # Divimos imagen en dos p\u00e1ginas del cuadernillo\n                img_p1, img_p2 = proc.partir_imagen_por_mitad(img_sin_franja)\n\n                # Para cada una de las dos im\u00e1genes del cuadernillo\n                for p, media_img in enumerate([img_p1, img_p2]):\n                    if p == 1 and num_pag == 0 and ignorar_primera_pagina:\n                        continue\n\n                    # Detecto recuadros naranjos\n                    mask_naranjo = get_mask_imagen(media_img)\n\n                    # Obtengo contornos\n                    big_contours = proc.get_contornos_grandes(mask_naranjo)\n\n\n\n                    # Para cada contorno de pregunta:\n                    for pregunta in (big_contours):\n\n                        # Obtengo n\u00b0 de pregunta en base a l\u00f3gica de cuadernillo:\n                        q = calcular_pregunta_actual(pages, p, dic_q) # Ojo, funci\u00f3n actualiza dic_q\n\n\n\n                        diccionario_nivel = poblar_diccionario_preguntas(q, diccionario_nivel,\n                                                                            nivel=nivel,\n                                                                            dir_pag=dir_pag,\n                                                                            page=pages[p])\n\n\n\n    return diccionario_nivel\n</code></pre>"},{"location":"generar_insumos_img/#simce.generar_insumos_img.generar_insumos","title":"<code>generar_insumos(tipo_cuadernillo, directorios)</code>","text":"<p>Funci\u00f3n principal. Genera todos los insumos para un tipo de cuadernillo espec\u00edfico (estudiantes o padres), es decir:     n\u00b0 de p\u00e1ginas, n\u00b0 de preguntas, n\u00b0 de subpreguntas, imagen asociada a cada pregunta, p\u00e1gina asociada a cada pregunta,     n\u00b0 de subpreguntas en cada pregunta, n\u00b0 de recuadros en cada pregunta.</p> <p>Parameters:</p> Name Type Description Default <code>tipo_cuadernillo</code> <code>str</code> <p>toma valor estudiantes o padres seg\u00fan el cuadernillo al que se le generen los insumos</p> required <code>directorios</code> <code>dict[str, PathLike]</code> <p>diccionario que contiene directorios del proyecto.</p> required <p>Returns:</p> Name Type Description <code>insumos_tipo_cuadernillo</code> <code>dict[str, str]</code> <p>json-like que contiene cada uno de los insumos para el cuadernillo ingresado.</p> Source code in <code>simce/generar_insumos_img.py</code> <pre><code>def generar_insumos(tipo_cuadernillo:str, directorios:dict[str, os.PathLike])-&gt; dict[str, str]:\n    '''\n    Funci\u00f3n principal. Genera todos los insumos para un tipo de cuadernillo espec\u00edfico (estudiantes o padres), es decir:\n        n\u00b0 de p\u00e1ginas, n\u00b0 de preguntas, n\u00b0 de subpreguntas, imagen asociada a cada pregunta, p\u00e1gina asociada a cada pregunta,\n        n\u00b0 de subpreguntas en cada pregunta, n\u00b0 de recuadros en cada pregunta.\n\n    Args:\n        tipo_cuadernillo: toma valor estudiantes o padres seg\u00fan el cuadernillo al que se le generen los insumos\n\n        directorios: diccionario que contiene directorios del proyecto.\n\n    Returns:\n        insumos_tipo_cuadernillo: json-like que contiene cada uno de los insumos para el cuadernillo ingresado.\n    '''\n\n\n    directorio_imagenes = proc.select_directorio(tipo_cuadernillo, directorios)\n\n    # El nombre de la carpeta que refiere a padres o estudiantes es tambi\u00e9n el nombre de la hoja en el Excel\n    sheet_name = directorio_imagenes.name\n\n    df_para_insumos = pd.read_excel(directorios['dir_input'] / nombre_tabla_para_insumos,\n                    skiprows=n_filas_ignorar_tabla_insumos, sheet_name=sheet_name)\n    df_para_insumos = df_para_insumos[df_para_insumos[nombre_col_campo_bd].notnull()]\n    df_preguntas = df_para_insumos[df_para_insumos[nombre_col_campo_bd].str.contains('p\\d+')].copy()\n\n    n_pages = get_n_paginas(directorio_imagenes)\n    n_preguntas = df_para_insumos[nombre_col_campo_bd].str.extract('(p\\d+)').nunique().iloc[0]\n    dic_cuadernillo = get_preg_por_hoja(n_pages, n_preguntas,\n                                         directorio_imagenes , nivel='cuadernillo')\n    dic_pagina = get_preg_por_hoja(n_pages, n_preguntas,\n                                    directorio_imagenes, nivel='pagina')\n    subpreg_x_preg = get_subpreg_x_preg(df_preguntas)\n    n_subpreg_tot = df_para_insumos[nombre_col_campo_bd].str.contains('^p\\d').sum()\n    n_recuadros_x_subpreg = (df_preguntas\n                                .set_index('p'+df_preguntas.preg.astype('string'))[nombre_col_val_permitidos]\n                                .apply(lambda x: get_recuadros_x_subpreg(x))\n                                .to_dict())\n    insumos_tipo_cuadernillo = {'n_pages': n_pages,\n                                'n_preguntas': str(n_preguntas),\n                                'n_subpreg_tot': str(n_subpreg_tot),\n                                'dic_cuadernillo': dic_cuadernillo,\n                                'dic_pagina': dic_pagina,\n                                'subpreg_x_preg': subpreg_x_preg,\n                                'n_recuadros_x_subpreg': n_recuadros_x_subpreg}\n\n    return insumos_tipo_cuadernillo\n</code></pre>"},{"location":"generar_insumos_img/#simce.generar_insumos_img.generar_insumos_total","title":"<code>generar_insumos_total(directorios)</code>","text":"<p>Corre funci\u00f3n que genera insumos para  estudiantes y padres y luego los exporta como json. Solo retorna un print que confirma que datos se exportaron.</p> <p>Parameters:</p> Name Type Description Default <code>directorios</code> <code>dict[str, PathLike]</code> <p>diccionario que contiene directorios del proyecto.</p> required Source code in <code>simce/generar_insumos_img.py</code> <pre><code>@timing\ndef generar_insumos_total(directorios:dict[str, os.PathLike]):\n    '''Corre [funci\u00f3n que genera insumos](../generar_insumos_img#simce.generar_insumos_img.generar_insumos) para \n    estudiantes y padres y luego los exporta como json. **Solo retorna un print que confirma que datos se exportaron**.\n\n    Args:\n        directorios: diccionario que contiene directorios del proyecto.\n\n\n    '''\n    print('Generando insumos estudiantes...')\n\n    insumos_est = generar_insumos(tipo_cuadernillo='estudiantes', directorios=directorios)\n    print('Generando insumos padres...')\n\n    insumos_padres = generar_insumos(tipo_cuadernillo='padres', directorios=directorios)\n\n    insumos = {'estudiantes': insumos_est,\n               'padres': insumos_padres}\n\n    dir_insumos = directorios['dir_insumos']\n    with open(dir_insumos / 'insumos.json', 'w') as fp:\n        json.dump(insumos, fp)\n\n\n    return print('Insumos generados exitosamente!')\n</code></pre>"},{"location":"generar_insumos_img/#simce.generar_insumos_img.get_n_paginas","title":"<code>get_n_paginas(directorio_imagenes)</code>","text":"<p>Obtiene el n\u00b0 de p\u00e1ginas totales del cuadernillo SIMCE. Para esto obtiene todos los archivos de un alumno y multiplica el total de archivos por 2.</p> <p>Parameters:</p> Name Type Description Default <code>directorio_imagenes</code> <code>str</code> <p>string que contiene el directorio en que se encuentran im\u00e1genes de cuadernillos.</p> required <p>Returns:</p> Name Type Description <code>n_pages</code> <code>int</code> <p>n\u00b0 de p\u00e1ginas totales del cuadernillo.</p> Source code in <code>simce/generar_insumos_img.py</code> <pre><code>def get_n_paginas(directorio_imagenes: str)-&gt;int:\n    '''Obtiene el n\u00b0 de p\u00e1ginas totales del cuadernillo SIMCE. Para esto obtiene\n    todos los archivos de un alumno y multiplica el total de archivos por 2.\n\n    Args:\n        directorio_imagenes: string que contiene el directorio en que se encuentran im\u00e1genes\n            de cuadernillos.\n\n    Returns:\n        n_pages: n\u00b0 de p\u00e1ginas totales del cuadernillo.\n    '''\n    rbds = list(directorio_imagenes.iterdir())\n    rbd1 = rbds[0]\n\n    estudiantes_rbd = {re.search(f'({regex_estudiante})', str(i)).group(1)\n                       for i in rbd1.rglob('*jpg')}\n    n_files = len(list(rbd1.glob(f'{estudiantes_rbd.pop()}*')))\n    n_pages = n_files * 2\n\n    return n_pages\n</code></pre>"},{"location":"generar_insumos_img/#simce.generar_insumos_img.get_paginas_actuales_cuadernillo","title":"<code>get_paginas_actuales_cuadernillo(num_pag, paginas_anteriores)</code>","text":"<p>M\u00e9todo program\u00e1tico para obtener p\u00e1ginas del cuadernillo que se est\u00e1n procesando en la imagen actualmente abierta. Dado que siempre una p\u00e1gina tiene preguntas que vienen en orden ascendente y la otra en orden descendente (por la l\u00f3gica de cuadernillo), se incorpora esto en el algoritmo. Se actualiza en cada iteraci\u00f3n del loop.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; get_paginas_actuales_cuadernillo(3, (10, 3))\n(4, 9)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>num_pag</code> <code>int</code> <p>n\u00famero de imagen del cuadernillo que se est\u00e1 procesando. Parte en 0.</p> required <code>paginas_anteriores</code> <code>tuple[int, int]</code> <p>tupla que contiene p\u00e1ginas del cuadernillo en la iteraci\u00f3n anterior. Ejemplo: (10,3) para la p\u00e1gina 2 del cuadernillo estudiantes 2023</p> required <p>Returns:</p> Name Type Description <code>paginas_actuales</code> <code>tuple[int, int]</code> <p>tupla actualizada con p\u00e1ginas del cuadernillo siendo procesadas actualmente</p> Source code in <code>simce/generar_insumos_img.py</code> <pre><code>def get_paginas_actuales_cuadernillo(num_pag:int, paginas_anteriores: tuple[int, int])-&gt;tuple[int, int]:\n    '''M\u00e9todo program\u00e1tico para obtener p\u00e1ginas del cuadernillo que se est\u00e1n\n    procesando en la imagen actualmente abierta. Dado que siempre una p\u00e1gina tiene preguntas\n    que vienen en orden ascendente y la otra en orden descendente (por la l\u00f3gica de cuadernillo), se incorpora\n    esto en el algoritmo. Se actualiza en cada iteraci\u00f3n del loop.\n\n    Examples:\n        &gt;&gt;&gt; get_paginas_actuales_cuadernillo(3, (10, 3))\n        (4, 9)\n\n    Args:\n        num_pag: n\u00famero de imagen del cuadernillo que se est\u00e1 procesando. Parte en 0.\n\n        paginas_anteriores: tupla que contiene p\u00e1ginas del cuadernillo en la iteraci\u00f3n anterior.\n            Ejemplo: (10,3) para la p\u00e1gina 2 del cuadernillo estudiantes 2023\n\n\n    Returns:\n        paginas_actuales: tupla actualizada con p\u00e1ginas del cuadernillo siendo procesadas actualmente\n\n\n    '''\n\n    if num_pag == 0:\n        pass\n    # si num_pag es par y no es la primera p\u00e1gina\n    elif (num_pag % 2 == 0):\n        paginas_actuales = (paginas_anteriores[1]-1, paginas_anteriores[0] + 1)\n    elif num_pag % 2 == 1:\n        paginas_actuales = (paginas_anteriores[1]+1, paginas_anteriores[0] - 1)\n\n    return paginas_actuales\n</code></pre>"},{"location":"generar_insumos_img/#simce.generar_insumos_img.get_preg_por_hoja","title":"<code>get_preg_por_hoja(n_pages, n_preguntas, directorio_imagenes, nivel='cuadernillo')</code>","text":"<p>Funci\u00f3n que puebla diccionario completo que mapea preguntas del cuestionario a su hoja o imagen correspondiente en el cuadernillo. Utiliza como insumo el n\u00famero de p\u00e1ginas del cuadernillo y el n\u00b0 de preguntas del cuestionario.</p> <p>Parameters:</p> Name Type Description Default <code>n_pages</code> <code>int</code> <p>n\u00famero de p\u00e1ginas del cuadernillo</p> required <code>n_preguntas</code> <code>int</code> <p>n\u00famero de preguntas del cuadernillo</p> required <code>directorio_imagenes</code> <code>PathLike</code> <p>directorio donde se encuentran im\u00e1genes del tipo de</p> required <code>nivel</code> <code>str</code> <p>indica si se est\u00e1 obteniendo diccionario a nivel cuadernillo o p\u00e1gina.</p> <code>'cuadernillo'</code> <p>Returns:</p> Name Type Description <code>diccionario_nivel</code> <code>dict</code> <p>diccionario donde las llaves son cada una de las preguntas del cuadernillo y los  valores son el n\u00b0 de p\u00e1gina o imagen que le corresponde, seg\u00fan si nivel es \"p\u00e1gina\" o \"cuadernillo\", respectivamente.</p> Source code in <code>simce/generar_insumos_img.py</code> <pre><code>def get_preg_por_hoja(n_pages:int, n_preguntas:int,\n                       directorio_imagenes:os.PathLike, nivel:str='cuadernillo' )-&gt;dict:\n    '''Funci\u00f3n que puebla diccionario completo que mapea preguntas del cuestionario a su hoja o imagen\n    correspondiente en el cuadernillo. Utiliza como insumo el n\u00famero de p\u00e1ginas del cuadernillo y el n\u00b0\n    de preguntas del cuestionario.\n\n\n    Args:\n        n_pages: n\u00famero de p\u00e1ginas del cuadernillo\n\n        n_preguntas: n\u00famero de preguntas del cuadernillo\n\n        directorio_imagenes: directorio donde se encuentran im\u00e1genes del tipo de\n        cuadernillo que se est\u00e1 procesando (padres o estudiantes).\n\n        nivel: indica si se est\u00e1 obteniendo diccionario a nivel cuadernillo o p\u00e1gina.\n\n\n    Returns:\n        diccionario_nivel: diccionario donde las llaves son cada una de las preguntas del cuadernillo y los \n            valores son el n\u00b0 de p\u00e1gina o imagen que le corresponde, seg\u00fan si nivel es \"p\u00e1gina\" o \"cuadernillo\",\n            respectivamente.\n\n\n    '''\n\n    if nivel not in proc.VALID_INPUT:\n        raise ValueError(f\"nivel debe ser uno de los siguientes valores: {proc.VALID_INPUT}\")\n\n    primer_est = re.search(\n        f'({regex_estudiante})',\n        # primer estudiante del primer rbd:\n        str(next(next(directorio_imagenes.iterdir()).iterdir()))).group(1)\n\n    diccionario_nivel = generar_diccionarios_x_pagina(n_pages, n_preguntas, directorio_imagenes,\n                                    filter_estudiante=primer_est, nivel=nivel,\n                                    ignorar_primera_pagina=IGNORAR_PRIMERA_PAGINA)\n    return diccionario_nivel\n</code></pre>"},{"location":"generar_insumos_img/#simce.generar_insumos_img.get_recuadros_x_subpreg","title":"<code>get_recuadros_x_subpreg(value)</code>","text":"<p>Extrae de las celdas el n\u00famero de opciones posibles en cada pregunta. Se excluyen del string las opciones     Vac\u00edo y doble marca, que no representan recuadros en la pr\u00e1ctica.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; get_recuadros_x_subpreg(\n\"0: vacio\n1: Nada capaz\n2: Poco capaz\n3: Bastante capaz\n4: Muy capaz\n99: doble marca\")\n4\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>string de la celda que contiene valores posibles de subpregunta, proveniente de Excel</p> required <p>Returns:</p> Name Type Description <code>n_recuadros_x_subpreg</code> <code>int</code> <p>N\u00b0 de recuadros en subpregunta para la que se est\u00e1 calculando.</p> Source code in <code>simce/generar_insumos_img.py</code> <pre><code>def get_recuadros_x_subpreg(value: str)-&gt;int:\n    '''Extrae de las celdas el n\u00famero de opciones posibles en cada pregunta. Se excluyen del string las opciones\n        Vac\u00edo y doble marca, que no representan recuadros en la pr\u00e1ctica.\n\n    Examples:\n        &gt;&gt;&gt; get_recuadros_x_subpreg(\n        \"0: vacio\n        1: Nada capaz\n        2: Poco capaz\n        3: Bastante capaz\n        4: Muy capaz\n        99: doble marca\")\n        4\n\n    Args:\n        value: string de la celda que contiene valores posibles de subpregunta, proveniente de Excel\n\n    Returns:\n        n_recuadros_x_subpreg: N\u00b0 de recuadros en subpregunta para la que se est\u00e1 calculando. \n\n    '''\n    list_valores = value.split('\\n')\n\n    n_recuadros_x_subpreg = len([i for i in list_valores if not re.search('(vac[i\u00ed]o)|99', i, re.IGNORECASE)])\n\n    return n_recuadros_x_subpreg\n</code></pre>"},{"location":"generar_insumos_img/#simce.generar_insumos_img.get_subpreg_x_preg","title":"<code>get_subpreg_x_preg(df_preguntas)</code>","text":"<p>Funci\u00f3n que puebla diccionario que mapea para cada pregunta, cu\u00e1ntas subpreguntas tiene asociada.</p> <p>Parameters:</p> Name Type Description Default <code>df_preguntas</code> <code>DataFrame</code> <p>DataFrame en que cada celda es una subpregunta para un SIMCE espec\u00edfico.</p> required <p>Returns:</p> Name Type Description <code>subpreg_x_preg</code> <code>dict</code> <p>diccionario donde las llaves son cada una de las preguntas del cuadernillo y los  valores son el n\u00b0 de subpreguntas asociados a esa pregunta.</p> Source code in <code>simce/generar_insumos_img.py</code> <pre><code>def get_subpreg_x_preg(df_preguntas: pd.DataFrame)-&gt; dict:\n    '''Funci\u00f3n que puebla diccionario que mapea para cada pregunta, cu\u00e1ntas subpreguntas tiene asociada.\n\n\n    Args:\n        df_preguntas: DataFrame en que cada celda es una subpregunta para un SIMCE espec\u00edfico.\n\n\n    Returns:\n        subpreg_x_preg: diccionario donde las llaves son cada una de las preguntas del cuadernillo y los \n            valores son el n\u00b0 de subpreguntas asociados a esa pregunta.\n\n\n    '''\n\n    df_preguntas['preg'] = df_preguntas[nombre_col_campo_bd].str.extract('^p(\\d+)').astype(int)\n    subpreg_x_preg = df_preguntas['preg'].value_counts().sort_index()\n    subpreg_x_preg.index = 'p' + subpreg_x_preg.index.astype('string') \n    subpreg_x_preg = subpreg_x_preg.to_dict()\n    return subpreg_x_preg\n</code></pre>"},{"location":"generar_insumos_img/#simce.generar_insumos_img.poblar_diccionario_preguntas","title":"<code>poblar_diccionario_preguntas(q, dic_paginas, nivel='cuadernillo', dir_pag=None, page=None)</code>","text":"<p>Funci\u00f3n va poblando un diccionario que, para cada pregunta del cuestionario, indica a qu\u00e9 p\u00e1gina del cuadernillo pertenece o a qu\u00e9 imagen pertenece, si el nivel es p\u00e1gina o cuadernillo, respectivamente.</p> <p>Por ejemplo, si usamos el diccionario de estudiantes 2023, buscamos el valor asociado a p21, nos dir\u00e1 que esta se encuentra en la imagen 3 del cuadernillo (nivel cuadernillo) o en la p\u00e1gina 10 del cuadernillo (nivel p\u00e1gina).</p> <p>Parameters:</p> Name Type Description Default <code>q</code> <code>int</code> <p>pregunta siendo poblada actualmente en el diccionario. Por ejemplo, 2, 14.</p> required <code>dic_paginas</code> <code>dict</code> <p>diccionario siendo poblado, puede ser a nivel de cuadernillo (imagen) o de p\u00e1gina del cuadernillo</p> required <code>nivel</code> <code>str</code> <p>nivel del diccionario que estamos poblando: cuadernillo o p\u00e1gina.</p> <code>'cuadernillo'</code> <code>dir_pag</code> <code>None | PathLike</code> <p>directorio de imagen siendo procesada actualmente (solo se usa si es a                                                                        nivel cuadernillo)</p> <code>None</code> <code>page</code> <code>int | None</code> <p>p\u00e1gina del cuadernillo siendo procesada actualmente (solo se usa si es a nivel p\u00e1gina)</p> <code>None</code> <p>Returns:</p> Name Type Description <code>dic_paginas</code> <code>dict</code> <p>diccionario actualizado con la pregunta q.</p> Source code in <code>simce/generar_insumos_img.py</code> <pre><code>def poblar_diccionario_preguntas(q: int, dic_paginas:dict, nivel:str='cuadernillo',\n                                 dir_pag:None|os.PathLike=None, page:int|None=None)-&gt;dict:\n    '''Funci\u00f3n va poblando un diccionario que, para cada pregunta del cuestionario, indica a qu\u00e9 p\u00e1gina\n    del cuadernillo pertenece o a qu\u00e9 imagen pertenece, si el nivel es p\u00e1gina o cuadernillo,\n    respectivamente.\n\n    Por ejemplo, si usamos el diccionario de estudiantes 2023, buscamos el valor asociado a p21, nos dir\u00e1\n    que esta se encuentra en la imagen 3 del cuadernillo (nivel cuadernillo) o en la p\u00e1gina 10 del\n    cuadernillo (nivel p\u00e1gina).\n\n    Args:\n        q: pregunta siendo poblada actualmente en el diccionario. Por ejemplo, 2, 14.\n\n        dic_paginas: diccionario siendo poblado, puede ser a nivel de cuadernillo (imagen) o de\n            p\u00e1gina del cuadernillo\n\n        nivel: nivel del diccionario que estamos poblando: cuadernillo o p\u00e1gina.\n\n        dir_pag: directorio de imagen siendo procesada actualmente (solo se usa si es a\n                                                                                   nivel cuadernillo)\n\n        page: p\u00e1gina del cuadernillo siendo procesada actualmente (solo se usa si es a nivel p\u00e1gina)\n\n    Returns:\n        dic_paginas: diccionario actualizado con la pregunta q.\n\n\n    '''\n\n    if nivel == 'cuadernillo':\n        print(dir_pag)\n        hoja_cuadernillo = re.search(regex_hoja_cuadernillo, dir_pag.name).group(1)\n        dic_paginas[f'p{q}'] = hoja_cuadernillo\n    elif nivel == 'pagina':\n        dic_paginas[f'p{q}'] = page\n\n    return dic_paginas\n</code></pre>"},{"location":"proc_imgs/","title":"Recorte de subpreguntas","text":"<p>En este manual se repasan las funciones asociadas al procesamiento de im\u00e1genes que permite un adecuado recorte de subpreguntas.</p> <p>Created on Thu May  2 17:22:37 2024</p> <p>@author: jeconchao</p>"},{"location":"proc_imgs/#simce.proc_imgs.get_insumos","title":"<code>get_insumos(tipo_cuadernillo, dir_insumos)</code>","text":"<p>Carga insumos obtenidos en el m\u00f3dulo de generaci\u00f3n de insumos</p> <p>Parameters:</p> Name Type Description Default <code>tipo_cuadernillo</code> <code>str</code> <p>tipo de cuadernillo a revisar: \"estudiantes\" o \"padres\".</p> required <code>dir_insumos</code> <code>PathLike</code> <p>directorio en el que se encuentran datos de insumos.</p> required <p>Returns:</p> Name Type Description <code>insumos_total</code> <p>tupla que contiene cada uno de los insumos, es decir: n_pages, n_preguntas, subpreg_x_preg, dic_cuadernillo, dic_pagina, n_subpreg_tot.</p> Source code in <code>simce/proc_imgs.py</code> <pre><code>def get_insumos(tipo_cuadernillo:str, dir_insumos:os.PathLike):\n    '''Carga insumos obtenidos en el [m\u00f3dulo de generaci\u00f3n de insumos](../generar_insumos_img)\n\n    Args:\n        tipo_cuadernillo: tipo de cuadernillo a revisar: \"estudiantes\" o \"padres\".\n\n        dir_insumos: directorio en el que se encuentran datos de insumos.\n\n    Returns:\n        insumos_total: tupla que contiene cada uno de los insumos, es decir:\n            n_pages, n_preguntas, subpreg_x_preg, dic_cuadernillo, dic_pagina, n_subpreg_tot.\n\n    '''\n    with open(dir_insumos / 'insumos.json') as f:\n        insumos = json.load(f)\n\n    # Seleccionamos insumos para el tipo de cuadernillo que estamos trabajando\n    insumos_usar = insumos[tipo_cuadernillo]\n\n    n_pages = insumos_usar['n_pages']\n    n_preguntas = insumos_usar['n_preguntas']\n    subpreg_x_preg = insumos_usar['subpreg_x_preg']\n    dic_cuadernillo = insumos_usar['dic_cuadernillo']\n    dic_pagina = insumos_usar['dic_pagina']\n    n_subpreg_tot = insumos_usar['n_subpreg_tot']\n\n    insumos_total = n_pages, n_preguntas, subpreg_x_preg, dic_cuadernillo, dic_pagina, n_subpreg_tot\n\n    return insumos_total\n</code></pre>"},{"location":"proc_imgs/#simce.proc_imgs.get_subpreguntas","title":"<code>get_subpreguntas(tipo_cuadernillo, directorios, curso='4b', filter_rbd=None, filter_estudiante=None, filter_rbd_int=False, muestra=False)</code>","text":"<p>Obtiene las cada una de las subpreguntas obtenidas de la funci\u00f3n get_tablas_99(). Esto considera dos casos: si es para predicci\u00f3n obtendr\u00e1 las im\u00e1genes de todas las sospechas de doble marca de la tabla de origen y si es para entrenamiento, adem\u00e1s considerar\u00e1 aproximadamente un 20% extra de marcas normales (depende de variable para_entrenamiento. Variable global IS_TRAINING define esto). Funci\u00f3n exporta im\u00e1genes para cada subpregunta de la tabla de entrenamiento o predicci\u00f3n.</p> <p>Parameters:</p> Name Type Description Default <code>tipo_cuadernillo</code> <code>str</code> <p>define si se est\u00e1 procesando para estudiantes o padres. Esto tambi\u00e9n</p> required <code>para_entrenamiento</code> <code>bool</code> <p>define si el procesamiento se est\u00e1 realizando para generar una base de</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>simce/proc_imgs.py</code> <pre><code>def get_subpreguntas(tipo_cuadernillo, directorios, curso='4b', filter_rbd=None, filter_estudiante=None,\n                     filter_rbd_int=False, muestra=False):\n    '''\n    Obtiene las cada una de las subpreguntas obtenidas de la funci\u00f3n get_tablas_99(). Esto considera dos\n    casos: si es para predicci\u00f3n obtendr\u00e1 las im\u00e1genes de todas las sospechas de doble marca de la tabla\n    de origen y si es para entrenamiento, adem\u00e1s considerar\u00e1 aproximadamente un 20% extra de marcas\n    normales (depende de variable para_entrenamiento. Variable global IS_TRAINING define esto).\n    Funci\u00f3n exporta im\u00e1genes para cada subpregunta de la tabla de entrenamiento o predicci\u00f3n.\n\n    Args:\n        tipo_cuadernillo (str): define si se est\u00e1 procesando para estudiantes o padres. Esto tambi\u00e9n\n        se utiliza para definir las rutas a consultar\n\n        para_entrenamiento (bool): define si el procesamiento se est\u00e1 realizando para generar una base de\n        entrenamiento o de predicci\u00f3n\n\n\n    Returns:\n        None\n\n    '''\n    # Obtenemos directorio de im\u00e1genes (padres o estudiantes)\n    directorio_imagenes = select_directorio(tipo_cuadernillo, directorios)\n    dir_tabla_99 = directorios['dir_tabla_99']\n    dir_input = directorios['dir_input']\n    dir_subpreg = directorios['dir_subpreg']\n\n\n    # Definimos tabla a utilizar para seleccionar subpreguntas\n\n    nombre_tabla_casos99 = f'casos_99_compilados_{curso}_{tipo_cuadernillo}.csv'\n\n    df99 = pd.read_csv(\n        dir_tabla_99 / nombre_tabla_casos99, dtype={'rbd_ruta': 'string'}).sort_values('ruta_imagen')\n\n    if muestra:\n\n        rbd_disp = {i.name for i in directorio_imagenes.iterdir()}\n        df99 = df99[(df99.rbd_ruta.isin(rbd_disp))]\n\n    # Si queremos correr funci\u00f3n para rbd espec\u00edfico\n    if filter_rbd:\n        # Si queremos correr funci\u00f3n desde un rbd en adelante\n        if filter_rbd_int:\n            df99 = df99[(df99.rbd_ruta.astype(int).ge(filter_rbd))]\n\n        # Si queremos correr funci\u00f3n solo para el rbd ingresado\n        else:\n            df99 = df99[(df99.rbd_ruta.isin(filter_rbd))]\n\n    if filter_estudiante:\n        if isinstance(filter_estudiante, int):\n            filter_estudiante = [filter_estudiante]\n        df99 = df99[df99.serie.isin(filter_estudiante)]\n    df99.ruta_imagen = df99.ruta_imagen.str.replace('\\\\', '/')\n    dir_preg99 = [dir_input / i for i in df99.ruta_imagen]\n\n    n_pages, _, subpreg_x_preg, _, dic_pagina, _ = get_insumos(\n        tipo_cuadernillo, dir_insumos=directorios['dir_insumos'])\n\n    for num, rbd in enumerate(dir_preg99):\n\n        pregunta_selec = re.search(r'p(\\d{1,2})', df99.iloc[num].preguntas).group(0)\n\n        print('############################')\n        print(rbd)\n        print(f'{num=}')\n        print(f'{pregunta_selec=}')\n\n        print('############################')\n        print('\\n')\n\n        estudiante = re.search(f'({regex_estudiante})', str(rbd)).group(1)\n\n        # p\u00e1ginas del cuardenillo\n        pagina_pregunta = dic_pagina[pregunta_selec]\n\n        pages = get_pages(pagina_pregunta, n_pages)\n\n        dir_subpreg_rbd = (dir_subpreg / f'{directorio_imagenes.name}/{rbd.parent.name}')\n        dir_subpreg_rbd.mkdir(exist_ok=True, parents=True)\n\n        if not rbd.is_file():\n\n            preg_error = dir_subpreg_rbd / f'{estudiante}'\n            anotar_error(pregunta = str(preg_error),\n                         error = f'No existen archivos disponibles para serie {preg_error.name}',\n                         nivel_error = tipo_cuadernillo)\n            continue\n\n        # Para cada imagen del cuadernillo de un estudiante (2 p\u00e1g x img):\n\n        # Obtengo carpeta del rbd y archivo del estudiante a\n        # partir del path:\n        file = rbd.name\n\n        print(f'{file=}')\n\n        # Creamos directorio si no existe\n\n        # Leemos imagen\n        img_preg = cv2.imread(str(rbd), 1)\n        img_crop = recorte_imagen(img_preg, 0, 150, 50, 160)\n        # Eliminamos franjas negras en caso de existir\n        img_sin_franja = eliminar_franjas_negras(img_crop)\n\n        # Recortamos info innecesaria de imagen\n\n        # Divimos imagen en dos p\u00e1ginas del cuadernillo\n        paginas_cuadernillo = partir_imagen_por_mitad(img_sin_franja)\n\n        # {k: v for k, v dic_pagina.items() if }\n\n        # Seleccionamos p\u00e1gina que nos interesa, basado en diccionario de p\u00e1ginas\n        media_img = paginas_cuadernillo[pages.index(pagina_pregunta)]\n\n        # Detecto recuadros naranjos\n        mask_naranjo = get_mask_imagen(media_img)\n\n        # Obtengo contornos\n        big_contours = get_contornos_grandes(mask_naranjo)\n\n        q_base = get_pregunta_inicial_pagina(dic_pagina, pagina_pregunta)\n        pregunta_selec_int = int(re.search(r'\\d+', pregunta_selec).group(0))\n        try:\n            # Obtengo coordenadas de contornos y corto imagen\n            elemento_img_pregunta = big_contours[pregunta_selec_int - q_base]\n            img_pregunta = bound_and_crop(media_img, elemento_img_pregunta)\n\n            img_pregunta_recuadros = dejar_solo_recuadros_subpregunta(img_pregunta)\n\n            # Exportamos pregunta si no tiene subpreguntas:\n            if subpreg_x_preg[pregunta_selec] == 1:\n                save_pregunta_completa(img_pregunta_recuadros, dir_subpreg_rbd, estudiante, pregunta_selec)\n                continue\n\n\n            subpreg_selec = df99.iloc[num].preguntas.split('_')[1]\n            print(f'{subpreg_selec=}')\n            # Obtenemos subpreguntas:\n\n            #  print(q)\n\n            # img_crop_col = get_mask_imagen(img_pregunta_recuadros,\n            #                                lower_color=np.array(\n            #                                    [0, 111, 109]),\n            #                                upper_color=np.array([18, 255, 255]))\n\n            img_crop_col = get_mascara_lineas_horizontales(img_pregunta_recuadros)\n\n            lineas_horizontales = obtener_lineas_horizontales(\n                img_crop_col, minLineLength=np.round(img_crop_col.shape[1] * .6))\n\n            n_subpreg = len(lineas_horizontales) - 1\n\n            if n_subpreg != subpreg_x_preg[pregunta_selec]:\n\n                preg_error = str(dir_subpreg_rbd / f'{estudiante}')\n\n                dic_dif = get_subpregs_distintas(subpreg_x_preg, dir_subpreg_rbd, estudiante)\n\n                error = f'N\u00b0 de subpreguntas incorrecto para serie {estudiante},\\\n        se encontraron {n_subpreg} subpreguntas {dic_dif}'\n\n                anotar_error(\n                    pregunta=preg_error, error=error, nivel_error = tipo_cuadernillo)\n\n            try:\n\n                file_out = str(\n                    dir_subpreg_rbd /\n                    f'{estudiante}_{pregunta_selec}_{int(subpreg_selec)}.jpg')\n                crop_and_save_subpreg(img_pregunta_recuadros, lineas_horizontales,\n                                      i=int(subpreg_selec)-1, file_out=file_out)\n\n            # Si hay error en procesamiento subpregunta\n            except Exception as e:\n\n                preg_error = str(\n                    dir_subpreg_rbd / f'{estudiante}_{pregunta_selec}_{int(subpreg_selec)}')\n                anotar_error(\n                    pregunta=preg_error,\n                    error='Subregunta no pudo ser procesada',\n                    nivel_error='Subpregunta',\n                    e=e)\n\n                continue\n\n\n\n                # Si hay error en procesamiento pregunta\n        except Exception as e:\n            print(e)\n\n            preg_error = str(dir_subpreg_rbd / f'{estudiante}_{pregunta_selec}')\n            anotar_error(\n                pregunta=preg_error, error='Pregunta no pudo ser procesada', e=e,\n                nivel_error='Pregunta')\n\n            continue\n\n    return '\u00c9xito!'\n</code></pre>"},{"location":"proc_imgs/#simce.proc_imgs.obtener_lineas_horizontales","title":"<code>obtener_lineas_horizontales(mask_lineas_rellenas, threshold=100, minLineLength=200)</code>","text":"<p>Funcion que identifica lineas para obtener puntos en el eje \"y\" para realizar el recorte a subpreguntas</p> <p>Parameters:</p> Name Type Description Default <code>img_crop_canny</code> <code>_type_</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>lines</code> <p>description</p> Source code in <code>simce/proc_imgs.py</code> <pre><code>def obtener_lineas_horizontales(mask_lineas_rellenas, threshold=100, minLineLength=200):\n    \"\"\"\n    Funcion que identifica lineas para obtener puntos en el eje \"y\" para realizar el recorte a\n    subpreguntas\n\n    Args:\n        img_crop_canny (_type_): _description_\n\n    Returns:\n        lines: _description_\n    \"\"\"\n    # obteniendo lineas\n\n\n    lines = cv2.HoughLinesP(mask_lineas_rellenas, 1, np.pi/180,\n                            threshold=threshold, minLineLength=minLineLength)\n\n\n\n    if lines is not None:\n\n        indices_ordenados = np.argsort(lines[:, :, 1].flatten())\n        lines_sorted = lines[indices_ordenados]\n\n        puntoy = list(set(chain.from_iterable(lines_sorted[:, :, 1].tolist())))\n        puntoy.append(mask_lineas_rellenas.shape[0])\n        puntoy = sorted(puntoy)\n\n        # print(puntoy)\n\n        y = []\n        for i in range(len(puntoy)-1):\n            if puntoy[i+1] - puntoy[i] &lt; n_pixeles_entre_lineas:\n                y.append(i+1)\n\n        # print(puntoy)\n        # print(y)\n\n        for index in sorted(y, reverse=True):\n            del puntoy[index]\n\n        return puntoy\n    else:\n        # Pregunta no cuenta con subpreguntas\n        return None\n</code></pre>"},{"location":"proc_imgs/#simce.proc_imgs.procesamiento_antiguo","title":"<code>procesamiento_antiguo(media_img)</code>","text":"<p>Funci\u00f3n en desuso. Procesaba imagen para detecci\u00f3n de contornos</p> Source code in <code>simce/proc_imgs.py</code> <pre><code>def procesamiento_antiguo(media_img):\n    '''Funci\u00f3n en desuso. Procesaba imagen para detecci\u00f3n de contornos'''\n\n    gray = cv2.cvtColor(media_img, cv2.COLOR_BGR2GRAY)  # convert roi into gray\n    # Blur=cv2.GaussianBlur(gray,(5,5),1) #apply blur to roi\n    # Canny=cv2.Canny(Blur,10,50) #apply canny to roi\n    _, It = cv2.threshold(gray, 0, 255, cv2.THRESH_OTSU)\n    sx = cv2.Sobel(It, cv2.CV_32F, 1, 0)\n    sy = cv2.Sobel(It, cv2.CV_32F, 0, 1)\n    m = cv2.magnitude(sx, sy)\n    m = cv2.normalize(m, None, 0., 255., cv2.NORM_MINMAX, cv2.CV_8U)\n    m = cv2.ximgproc.thinning(m, None, cv2.ximgproc.THINNING_GUOHALL)\n    kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (3, 3))\n    m = cv2.dilate(m, kernel, iterations=2)\n</code></pre>"},{"location":"proc_imgs/#simce.proc_imgs.procesamiento_color","title":"<code>procesamiento_color(img_crop)</code>","text":"<p>Funcion que procesa el color de la imagen</p> <p>Parameters:</p> Name Type Description Default <code>img_crop</code> <code>_type_</code> <p>imagen recortada</p> required <p>Returns:</p> Type Description <p>canny image</p> Source code in <code>simce/proc_imgs.py</code> <pre><code>def procesamiento_color(img_crop):\n    \"\"\"\n    Funcion que procesa el color de la imagen\n\n    Args:\n        img_crop (_type_): imagen recortada\n\n    Returns:\n        canny image\n    \"\"\"\n    # transformando color\n    gray = cv2.cvtColor(img_crop, cv2.COLOR_BGR2GRAY)\n    # blur = cv2.GaussianBlur(gray, (5, 5), 0)\n    Canny = cv2.Canny(gray, 50, 150, apertureSize=3)\n\n    return Canny\n</code></pre>"},{"location":"proc_imgs/#simce.proc_imgs.recorte_imagen","title":"<code>recorte_imagen(img_preg, x0=110, x1=20, y0=50, y1=50)</code>","text":"<p>Funcion para recortar margenes de las imagenes</p> <p>Parameters:</p> Name Type Description Default <code>img_preg</code> <code>array imagen</code> <p>description</p> required <code>x0</code> <code>int</code> <p>description. Defaults to 130.</p> <code>110</code> <code>x1</code> <code>int</code> <p>description. Defaults to 30.</p> <code>20</code> <code>y0</code> <code>int</code> <p>description. Defaults to 50.</p> <code>50</code> <code>y1</code> <code>int</code> <p>description. Defaults to 50.</p> <code>50</code> <p>Returns:</p> Type Description <code>array imagen</code> <p>imagen cortada</p> Source code in <code>simce/proc_imgs.py</code> <pre><code>def recorte_imagen(img_preg, x0=110, x1=20, y0=50, y1=50):\n    \"\"\"Funcion para recortar margenes de las imagenes\n\n    Args:\n        img_preg (array imagen): _description_\n        x0 (int, optional): _description_. Defaults to 130.\n        x1 (int, optional): _description_. Defaults to 30.\n        y0 (int, optional): _description_. Defaults to 50.\n        y1 (int, optional): _description_. Defaults to 50.\n\n    Returns:\n        (array imagen): imagen cortada\n    \"\"\"\n\n    x, y = img_preg.shape[:2]\n    img_crop = img_preg[x0:x-x1, y0:y-y1]\n    return img_crop\n</code></pre>"},{"location":"proc_imgs/#simce.proc_imgs.select_directorio","title":"<code>select_directorio(tipo_cuadernillo, directorios)</code>","text":"<p>Selecciona directorio de datos seg\u00fan si se est\u00e1 procesando el cuadernillo de padres o de estudiantes</p> Source code in <code>simce/proc_imgs.py</code> <pre><code>def select_directorio(tipo_cuadernillo, directorios):\n    '''Selecciona directorio de datos seg\u00fan si se est\u00e1 procesando el cuadernillo\n    de padres o de estudiantes'''\n\n    if tipo_cuadernillo == 'estudiantes':\n        directorio_imagenes = directorios['dir_estudiantes']\n\n    elif tipo_cuadernillo == 'padres':\n        directorio_imagenes = directorios['dir_padres']\n\n    return directorio_imagenes\n</code></pre>"}]}