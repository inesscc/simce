{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Modelo de detecci\u00f3n de dobles marcas SIMCE","text":"<p>La presente documentaci\u00f3n se encargar\u00e1 de explicar el c\u00f3digo del proyecto SIMCE, as\u00ed como su organizaci\u00f3n y c\u00f3mo correr el modelo. La estructura del documento es la siguiente:</p> <ol> <li>Estructura del proyecto</li> <li>Esquema del proyecto</li> <li>Tutorial de uso</li> <li>Gu\u00eda de outputs del proyecto</li> <li>Uso del script de configuraci\u00f3n</li> <li>Manuales de referencia</li> </ol> <p>En el men\u00fa de la izquierda es posible navegar por el sitio y los distintos manuales de referencia.</p>"},{"location":"#estructura-del-proyecto","title":"Estructura del proyecto","text":"<p>A continuaci\u00f3n se presenta la estructura del proyecto, con el fin de que sea posible entender qu\u00e9 hacen los distintos archivos y carpetas del proyecto.</p> <pre><code>simce/\n\u2502\n\u251c\u2500\u2500 get_recortes.py - script principal para obtener recortes de subpreguntas\n\u251c\u2500\u2500 get_predicciones.py - script principal para obtener predicciones del modelo.\n\u251c\u2500\u2500 modelo_simce.pt - archivo que contiene el modelo que predice dobles marcas\n\u2502\n\u251c\u2500\u2500 base/ - clases abstractas base\n\u2502   \u251c\u2500\u2500 base_data_loader.py\n\u2502   \u251c\u2500\u2500 base_model.py\n\u2502   \u2514\u2500\u2500 base_trainer.py\n\u2502\n\u251c\u2500\u2500 config/ - carpeta de configuraciones del proyecto\n\u2502   \u251c\u2500\u2500 config_pred.json - configuraci\u00f3n del modelo para predicci\u00f3n\n\u2502   \u251c\u2500\u2500 parse_config.py - clase que maneja archivo de configuraci\u00f3n y opciones CLI\n\u2502   \u2514\u2500\u2500 proc_img.py - configuraciones asociadas al recorte de subpreguntas.\n\u2502\n\u251c\u2500\u2500 data/ - carpeta con datos del modelo\n\u2502\n\u251c\u2500\u2500 data_loader/ - carga de datos en Torch \n\u2502   \u2514\u2500\u2500 data_loaders.py\n\u2502\n\u251c\u2500\u2500 dataset/ - clase que permite cargar dataset de im\u00e1genes en Torch\n\u2502   \u2514\u2500\u2500 dataset.py\n\u2502\n\u251c\u2500\u2500 docs/ - archivos de documentaci\u00f3n del proyecto\n\u2502   \u251c\u2500\u2500 index.md\n\u2502   \u2514\u2500\u2500 ...\n\u2502\n\u251c\u2500\u2500 logger/ - m\u00f3dulo para logging del modelo.\n\u2502   \u251c\u2500\u2500 visualization.py\n\u2502   \u251c\u2500\u2500 logger.py\n\u2502   \u2514\u2500\u2500 logger_config.json\n\u2502    \n\u251c\u2500\u2500 model/ - modelos, p\u00e9rdidas, y m\u00e9tricas\n\u2502   \u251c\u2500\u2500 model.py\n\u2502   \u251c\u2500\u2500 metric.py\n\u2502   \u2514\u2500\u2500 loss.py\n\u2502\n\u251c\u2500\u2500 notebooks/ - notebooks con pruebas y an\u00e1lisis exploratorio \n\u2502\n\u251c\u2500\u2500 saved/ - modelos entrenados y sus logs correspondientes\n\u2502   \u251c\u2500\u2500 models/ - trained models are saved here\n\u2502   \u2514\u2500\u2500 log/ - default logdir for tensorboard and logging output\n\u2502\n\u251c\u2500\u2500 simce/ - funciones que procesan las distintas etapas del proyecto\n\u2502   \u251c\u2500\u2500 errors.py - manejo de errores\n\u2502   \u251c\u2500\u2500 generar_insumos_img.py - genera los insumos que posteriormente son utilizados en el recorte\n\u2502   \u251c\u2500\u2500 indicadores_tinta.py - c\u00e1lculo de indicadores de tinta\n\u2502   \u251c\u2500\u2500 modelamiento.py - funciones utilizadas durante el modelamiento.\n\u2502   \u251c\u2500\u2500 paralelizacion.py - funciones del recorte de subpreguntas que se ejecutan de forma paralelizada\n\u2502   \u251c\u2500\u2500 predicciones.py - funciones para la predicci\u00f3n de datos nuevos\n\u2502   \u251c\u2500\u2500 preparar_modelamiento.py - funciones que preparan datos para el modelamiento  \n\u2502   \u251c\u2500\u2500 proc_imgs.py - funciones asociadas al procesamiento de im\u00e1genes previo al recorte\n\u2502   \u2514\u2500\u2500 proc_tabla_99.py - generaci\u00f3n de tabla de dobles marcas\n\u2502\n\u251c\u2500\u2500 site/ - archivos asociados a sitio web de documentaci\u00f3n\n\u2502    \u251c\u2500\u2500 assets/\n\u2502    \u2514\u2500\u2500 ...\n\u2502\n\u2514\u2500\u2500 trainer/ - clase trainer, permite entrenar un modelo\n    \u2514\u2500\u2500 trainer.py\n</code></pre>"},{"location":"#esquema-del-proyecto","title":"Esquema del proyecto","text":"<p>Aqu\u00ed podemos ver las distintas etapas que se ejecutan a lo largo de los c\u00f3digos, junto con los respectivos outputs:la tabla de errores en el procesamiento de im\u00e1genes (<code>problemas_imagenes.xlsx</code>) y la tabla de predicciones e indicadores (<code>predicciones_modelo_final.xlsx</code>)</p> <p></p> <p> </p>"},{"location":"generar_insumos_img/","title":"Generaci\u00f3n de insumos","text":"<p>En este manual se repasan las funciones asociadas a la generaci\u00f3n de insumos utilizados para facilitar el recorte de subpreguntas </p> <p>Created on Thu May 16 17:46:31 2024</p> <p>@author: jeconchao</p>"},{"location":"generar_insumos_img/#simce.generar_insumos_img.calcular_pregunta_actual","title":"<code>calcular_pregunta_actual(pages, p, dic_q)</code>","text":"<p>M\u00e9todo program\u00e1tico para obtener pregunta del cuadernillo que se est\u00e1     procesando. Dado que siempre una p\u00e1gina tiene preguntas que vienen en orden     ascendente y la otra en orden descendente (por la l\u00f3gica de cuadernillo), hubo     que incorporar esto en el algoritmo</p> <p>Parameters:</p> Name Type Description Default <code>pages</code> <code>tuple[int, int]</code> <p>tupla que contiene la p\u00e1gina izquierda y la p\u00e1gina derecha de la p\u00e1gina del     cuadernillo que se est\u00e1 procesando. Ejemplo: (10,3) para la p\u00e1gina 2 del cuadernillo     estudiantes 2023</p> required <code>p</code> <code>int</code> <p>integer que toma valor 0 \u00f3 1. Si es 0 es la primera p\u00e1gina del cuadernillo, si es  1, es la segunda.</p> required <code>dic_q</code> <code>dict</code> <p>diccionario que contiene dos llaves, q_bajo y q_alto. q_bajo es la pregunta actual desde el lado     bajo y q_alto es la pregunta actual desde el lado alto del cuadernillo.</p> required <p>Returns:</p> Name Type Description <code>q</code> <code>int</code> <p>pregunta actual siendo procesada</p> Source code in <code>simce\\generar_insumos_img.py</code> <pre><code>def calcular_pregunta_actual(pages: tuple[int, int], p: int, dic_q: dict)-&gt; int:\n    '''M\u00e9todo program\u00e1tico para obtener pregunta del cuadernillo que se est\u00e1\n        procesando. Dado que siempre una p\u00e1gina tiene preguntas que vienen en orden\n        ascendente y la otra en orden descendente (por la l\u00f3gica de cuadernillo), hubo\n        que incorporar esto en el algoritmo\n\n    Args:\n        pages: tupla que contiene la p\u00e1gina izquierda y la p\u00e1gina derecha de la p\u00e1gina del\n                cuadernillo que se est\u00e1 procesando. Ejemplo: (10,3) para la p\u00e1gina 2 del cuadernillo\n                estudiantes 2023\n\n        p: integer que toma valor 0 \u00f3 1. Si es 0 es la primera p\u00e1gina del cuadernillo, si es  1, es\n            la segunda.\n\n        dic_q: diccionario que contiene dos llaves, q_bajo y q_alto. q_bajo es la pregunta actual desde el lado\n                bajo y q_alto es la pregunta actual desde el lado alto del cuadernillo.\n\n    Returns:\n        q: pregunta actual siendo procesada\n\n    '''\n\n    # si es la p\u00e1g + alta del cuadernillo:\n    if pages[p] &gt; pages[1-p]:\n        dic_q['q_alto'] -= 1\n        return dic_q['q_alto']\n    # si es la p\u00e1g m\u00e1s baja del cuardenillo\n    elif (pages[p] &lt; pages[1-p]) &amp; (pages[p] != 1):\n        dic_q['q_bajo'] += 1\n        return dic_q['q_bajo']\n    else:  # Para la portada\n        return 0\n</code></pre>"},{"location":"generar_insumos_img/#simce.generar_insumos_img.generar_diccionarios_x_pagina","title":"<code>generar_diccionarios_x_pagina(n_pages, n_preguntas, directorio_imagenes, nivel, args, filter_rbd=None, filter_estudiante=None, ignorar_primera_pagina=True)</code>","text":"<p>Funci\u00f3n similar a get_subpreguntas() en el m\u00f3dulo de procesamiento de im\u00e1genes dise\u00f1ada para obtener todas las preguntas en uno o m\u00e1s cuadernillos espec\u00edficos. Se utiliza para insumar los diccionarios autom\u00e1ticos, en particular, preguntas por p\u00e1gina del cuadernillo y  preguntas por imagen del cuadernillo. </p> <p>Parameters:</p> Name Type Description Default <code>n_pages</code> <code>int</code> <p>n\u00b0 de p\u00e1ginas que tiene el cuestionario</p> required <code>n_preguntas</code> <code>int</code> <p>n\u00b0 de preguntas que tiene el cuestionario</p> required <code>directorio_imagenes</code> <code>PathLike</code> <p>directorio desde el que se recogen im\u00e1genes a procesar</p> required <code>nivel</code> <code>str</code> <p>variable que se utiliza cuando se generan insumos.</p> required <code>filter_rbd</code> <code>None | list | str</code> <p>permite filtrar uno o m\u00e1s RBDs espec\u00edficos y solo realizar la operaci\u00f3n sobre estos.</p> <code>None</code> <code>filter_estudiante</code> <code>None | list | str</code> <p>permite filtrar uno o m\u00e1s estudiantes espec\u00edficos y solo realizar la operaci\u00f3n sobre estos.</p> <code>None</code> <code>ignorar_primera_pagina</code> <code>bool</code> <p>booleano que indica si se debe ignorar la primera p\u00e1gina a la hora de  generar los diccionarios autom\u00e1ticos (en general primera p\u00e1gina contiene ejemplos que debemos ignorar.)</p> <code>True</code> <p>Returns:</p> Name Type Description <code>diccionario_nivel</code> <code>dict</code> <p>diccionario donde las llaves son cada una de las preguntas del cuadernillo y los  valores son el n\u00b0 de p\u00e1gina o imagen que le corresponde, seg\u00fan si nivel es \"p\u00e1gina\" o \"cuadernillo\", respectivamente</p> Source code in <code>simce\\generar_insumos_img.py</code> <pre><code>def generar_diccionarios_x_pagina(n_pages: int, n_preguntas:int, directorio_imagenes:os.PathLike,\n                              nivel:str, args: list,\n                              filter_rbd:None|list|str=None, filter_estudiante:None|list|str=None,\n                             ignorar_primera_pagina:bool=True,\n                             )-&gt;dict:\n    '''\n    Funci\u00f3n similar a get_subpreguntas() en el m\u00f3dulo de [procesamiento de im\u00e1genes](proc_imgs.md) dise\u00f1ada para obtener\n    todas las preguntas en uno o m\u00e1s cuadernillos espec\u00edficos.\n    Se utiliza para insumar los diccionarios autom\u00e1ticos, en particular, preguntas por p\u00e1gina del cuadernillo y \n    preguntas por imagen del cuadernillo. \n\n    Args:\n        n_pages: n\u00b0 de p\u00e1ginas que tiene el cuestionario\n\n        n_preguntas: n\u00b0 de preguntas que tiene el cuestionario\n\n        directorio_imagenes: directorio desde el que se recogen im\u00e1genes a procesar\n\n        nivel: variable que se utiliza cuando se generan insumos.\n\n        filter_rbd: permite filtrar uno o m\u00e1s RBDs espec\u00edficos y solo realizar la operaci\u00f3n sobre estos.\n\n        filter_estudiante: permite filtrar uno o m\u00e1s estudiantes espec\u00edficos y solo realizar la operaci\u00f3n sobre estos.\n\n        ignorar_primera_pagina: booleano que indica si se debe ignorar la primera p\u00e1gina a la hora de \n            generar los diccionarios autom\u00e1ticos (en general primera p\u00e1gina contiene ejemplos que debemos ignorar.)\n\n\n\n    Returns:\n        diccionario_nivel: diccionario donde las llaves son cada una de las preguntas del cuadernillo y los \n            valores son el n\u00b0 de p\u00e1gina o imagen que le corresponde, seg\u00fan si nivel es \"p\u00e1gina\" o \"cuadernillo\",\n            respectivamente \n\n    '''\n\n\n    # Si queremos correr funci\u00f3n para rbd espec\u00edfico\n    if filter_rbd:\n\n        # Si queremos correr funci\u00f3n solo para el rbd ingresado\n\n        if isinstance(filter_rbd, str):\n            filter_rbd = [filter_rbd]\n        directorios = [i for i in directorio_imagenes.iterdir() if i.name in filter_rbd]\n    else:\n        directorios = directorio_imagenes.iterdir()\n\n    # Permite armar diccionario con mapeo pregunta -&gt; p\u00e1gina cuadernillo (archivo input)\n    diccionario_nivel = dict()\n\n    for num, rbd in enumerate(directorios):\n        if not filter_estudiante:\n\n            print('############################')\n            print(rbd)\n            print(num)\n            print('############################')\n\n        estudiantes_rbd = {re.search(f'({regex_estudiante})', str(i)).group(1)\n                           for i in rbd.iterdir()}\n\n        # Si queremos correr funci\u00f3n para un estudiante espec\u00edfico:\n        if filter_estudiante:\n            if isinstance(filter_estudiante, str):\n                filter_estudiante = [filter_estudiante]\n            estudiantes_rbd = {\n                i for i in estudiantes_rbd if i in filter_estudiante}\n\n        for estudiante in estudiantes_rbd:\n\n\n            # p\u00e1ginas del cuardenillo\n            pages = (n_pages, 1)\n\n            dic_q = {\n                # pregunta inicial p\u00e1ginas bajas\n                'q_bajo': 0,\n                # pregunta inicial p\u00e1ginas altas\n                'q_alto': n_preguntas + 1}\n\n\n            # Para cada imagen del cuadernillo de un estudiante (2 p\u00e1g x img):\n            for num_pag, dir_pag in enumerate(sorted(list(rbd.glob(f'{estudiante}*')))):\n                # Creamos directorio para guardar im\u00e1genes\n\n                # Obtenemos p\u00e1ginas del cuadernillo actual:\n                pages = get_paginas_actuales_cuadernillo(num_pag, pages)\n\n                # Obtengo carpeta del rbd y archivo del estudiante a\n                # partir del path:\n                file = dir_pag.parts[-1]\n                if args.verbose:\n                    print(f'{file=}')\n                    print(f'{num_pag=}')\n\n                # Creamos directorio si no existe\n\n                # Leemos imagen\n                img_preg = cv2.imread(str(dir_pag), 1)\n                img_crop = proc.recorte_imagen(img_preg, 0, 150, 50, 160)\n                # Eliminamos franjas negras en caso de existir\n                img_sin_franja = proc.eliminar_franjas_negras(img_crop)\n\n                # Divimos imagen en dos p\u00e1ginas del cuadernillo\n                img_p1, img_p2 = proc.partir_imagen_por_mitad(img_sin_franja)\n\n                # Para cada una de las dos im\u00e1genes del cuadernillo\n                for p, media_img in enumerate([img_p1, img_p2]):\n                    if p == 1 and num_pag == 0 and ignorar_primera_pagina:\n                        continue\n\n                    # Detecto recuadros naranjos\n                    mask_naranjo = get_mask_imagen(media_img)\n\n                    # Obtengo contornos\n                    big_contours = proc.get_contornos_grandes(mask_naranjo)\n\n\n\n                    # Para cada contorno de pregunta:\n                    for pregunta in (big_contours):\n\n                        # Obtengo n\u00b0 de pregunta en base a l\u00f3gica de cuadernillo:\n                        q = calcular_pregunta_actual(pages, p, dic_q) # Ojo, funci\u00f3n actualiza dic_q\n\n\n\n                        diccionario_nivel = poblar_diccionario_preguntas(q, diccionario_nivel,\n                                                                            nivel=nivel,\n                                                                            dir_pag=dir_pag,\n                                                                            page=pages[p])\n\n\n\n    return diccionario_nivel\n</code></pre>"},{"location":"generar_insumos_img/#simce.generar_insumos_img.generar_insumos","title":"<code>generar_insumos(tipo_cuadernillo, directorios, args)</code>","text":"<p>Funci\u00f3n principal. Genera todos los insumos para un tipo de cuadernillo espec\u00edfico (estudiantes o padres), es decir:     n\u00b0 de p\u00e1ginas, n\u00b0 de preguntas, n\u00b0 de subpreguntas, imagen asociada a cada pregunta, p\u00e1gina asociada a cada pregunta,     n\u00b0 de subpreguntas en cada pregunta, n\u00b0 de recuadros en cada pregunta.</p> <p>Parameters:</p> Name Type Description Default <code>tipo_cuadernillo</code> <code>str</code> <p>toma valor estudiantes o padres seg\u00fan el cuadernillo al que se le generen los insumos</p> required <code>directorios</code> <code>dict[str, PathLike]</code> <p>diccionario que contiene directorios del proyecto.</p> required <p>Returns:</p> Name Type Description <code>insumos_tipo_cuadernillo</code> <code>dict[str, str]</code> <p>json-like que contiene cada uno de los insumos para el cuadernillo ingresado.</p> Source code in <code>simce\\generar_insumos_img.py</code> <pre><code>def generar_insumos(tipo_cuadernillo:str, directorios:dict[str, os.PathLike],\n                    args:argparse.Namespace)-&gt; dict[str, str]:\n    '''\n    Funci\u00f3n principal. Genera todos los insumos para un tipo de cuadernillo espec\u00edfico (estudiantes o padres), es decir:\n        n\u00b0 de p\u00e1ginas, n\u00b0 de preguntas, n\u00b0 de subpreguntas, imagen asociada a cada pregunta, p\u00e1gina asociada a cada pregunta,\n        n\u00b0 de subpreguntas en cada pregunta, n\u00b0 de recuadros en cada pregunta.\n\n    Args:\n        tipo_cuadernillo: toma valor estudiantes o padres seg\u00fan el cuadernillo al que se le generen los insumos\n\n        directorios: diccionario que contiene directorios del proyecto.\n\n    Returns:\n        insumos_tipo_cuadernillo: json-like que contiene cada uno de los insumos para el cuadernillo ingresado.\n    '''\n\n\n    directorio_imagenes = directorios[f'dir_{tipo_cuadernillo}']\n\n    # El nombre de la carpeta que refiere a padres o estudiantes es tambi\u00e9n el nombre de la hoja en el Excel\n    sheet_name = directorio_imagenes.name\n\n    df_para_insumos = pd.read_excel(directorios['dir_input'] / nombre_tabla_para_insumos,\n                    skiprows=n_filas_ignorar_tabla_insumos, sheet_name=sheet_name)\n    df_para_insumos = df_para_insumos[df_para_insumos[nombre_col_campo_bd].notnull()]\n    df_preguntas = df_para_insumos[df_para_insumos[nombre_col_campo_bd].str.contains(r'p\\d+')].copy()\n\n    n_pages = get_n_paginas(directorio_imagenes)\n    n_preguntas = df_para_insumos[nombre_col_campo_bd].str.extract(r'(p\\d+)').nunique().iloc[0]\n    dic_cuadernillo = get_preg_por_hoja(n_pages, n_preguntas,\n                                         directorio_imagenes , args=args, nivel='cuadernillo')\n    dic_pagina = get_preg_por_hoja(n_pages, n_preguntas,\n                                    directorio_imagenes, args=args, nivel='pagina')\n    subpreg_x_preg = get_subpreg_x_preg(df_preguntas)\n    n_subpreg_tot = df_para_insumos[nombre_col_campo_bd].str.contains(r'^p\\d').sum()\n    n_recuadros_x_subpreg = (df_preguntas\n                                .set_index('p'+df_preguntas.preg.astype('string'))[nombre_col_val_permitidos]\n                                .apply(lambda x: get_recuadros_x_subpreg(x))\n                                .to_dict())\n    insumos_tipo_cuadernillo = {'n_pages': n_pages,\n                                'n_preguntas': str(n_preguntas),\n                                'n_subpreg_tot': str(n_subpreg_tot),\n                                'dic_cuadernillo': dic_cuadernillo,\n                                'dic_pagina': dic_pagina,\n                                'subpreg_x_preg': subpreg_x_preg,\n                                'n_recuadros_x_subpreg': n_recuadros_x_subpreg}\n\n    return insumos_tipo_cuadernillo\n</code></pre>"},{"location":"generar_insumos_img/#simce.generar_insumos_img.generar_insumos_total","title":"<code>generar_insumos_total(directorios, args)</code>","text":"<p>Corre funci\u00f3n que genera insumos para  estudiantes y padres y luego los exporta como json. Solo retorna un print que confirma que datos se exportaron.</p> <p>Parameters:</p> Name Type Description Default <code>directorios</code> <code>dict[str, PathLike]</code> <p>diccionario que contiene directorios del proyecto.</p> required Source code in <code>simce\\generar_insumos_img.py</code> <pre><code>@timing\ndef generar_insumos_total(directorios:dict[str, os.PathLike], args:argparse.Namespace):\n    '''Corre [funci\u00f3n que genera insumos](../generar_insumos_img#simce.generar_insumos_img.generar_insumos) para \n    estudiantes y padres y luego los exporta como json. **Solo retorna un print que confirma que datos se exportaron**.\n\n    Args:\n        directorios: diccionario que contiene directorios del proyecto.\n\n\n    '''\n    print('Generando insumos estudiantes...')\n\n    insumos_est = generar_insumos(tipo_cuadernillo='estudiantes', directorios=directorios,\n                                  args=args)\n    print('Generando insumos padres...')\n\n    insumos_padres = generar_insumos(tipo_cuadernillo='padres', directorios=directorios, args=args)\n\n    insumos = {'estudiantes': insumos_est,\n               'padres': insumos_padres}\n\n    dir_insumos = directorios['dir_insumos']\n    with open(dir_insumos / 'insumos.json', 'w') as fp:\n        json.dump(insumos, fp)\n\n\n    return print('Insumos generados exitosamente!')\n</code></pre>"},{"location":"generar_insumos_img/#simce.generar_insumos_img.get_n_paginas","title":"<code>get_n_paginas(directorio_imagenes)</code>","text":"<p>Obtiene el n\u00b0 de p\u00e1ginas totales del cuadernillo SIMCE. Para esto obtiene todos los archivos de un alumno y multiplica el total de archivos por 2.</p> <p>Parameters:</p> Name Type Description Default <code>directorio_imagenes</code> <code>str</code> <p>string que contiene el directorio en que se encuentran im\u00e1genes de cuadernillos.</p> required <p>Returns:</p> Name Type Description <code>n_pages</code> <code>int</code> <p>n\u00b0 de p\u00e1ginas totales del cuadernillo.</p> Source code in <code>simce\\generar_insumos_img.py</code> <pre><code>def get_n_paginas(directorio_imagenes: str)-&gt;int:\n    '''Obtiene el n\u00b0 de p\u00e1ginas totales del cuadernillo SIMCE. Para esto obtiene\n    todos los archivos de un alumno y multiplica el total de archivos por 2.\n\n    Args:\n        directorio_imagenes: string que contiene el directorio en que se encuentran im\u00e1genes\n            de cuadernillos.\n\n    Returns:\n        n_pages: n\u00b0 de p\u00e1ginas totales del cuadernillo.\n    '''\n    rbds = list(directorio_imagenes.iterdir())\n    rbd1 = rbds[0]\n\n    estudiantes_rbd = {re.search(f'({regex_estudiante})', str(i)).group(1)\n                       for i in rbd1.rglob('*jpg')}\n    n_files = len(list(rbd1.glob(f'{estudiantes_rbd.pop()}*')))\n    n_pages = n_files * 2\n\n    return n_pages\n</code></pre>"},{"location":"generar_insumos_img/#simce.generar_insumos_img.get_paginas_actuales_cuadernillo","title":"<code>get_paginas_actuales_cuadernillo(num_pag, paginas_anteriores)</code>","text":"<p>M\u00e9todo program\u00e1tico para obtener p\u00e1ginas del cuadernillo que se est\u00e1n procesando en la imagen actualmente abierta. Dado que siempre una p\u00e1gina tiene preguntas que vienen en orden ascendente y la otra en orden descendente (por la l\u00f3gica de cuadernillo), se incorpora esto en el algoritmo. Se actualiza en cada iteraci\u00f3n del loop.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; get_paginas_actuales_cuadernillo(3, (10, 3))\n(4, 9)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>num_pag</code> <code>int</code> <p>n\u00famero de imagen del cuadernillo que se est\u00e1 procesando. Parte en 0.</p> required <code>paginas_anteriores</code> <code>tuple[int, int]</code> <p>tupla que contiene p\u00e1ginas del cuadernillo en la iteraci\u00f3n anterior. Ejemplo: (10,3) para la p\u00e1gina 2 del cuadernillo estudiantes 2023</p> required <p>Returns:</p> Name Type Description <code>paginas_actuales</code> <code>tuple[int, int]</code> <p>tupla actualizada con p\u00e1ginas del cuadernillo siendo procesadas actualmente</p> Source code in <code>simce\\generar_insumos_img.py</code> <pre><code>def get_paginas_actuales_cuadernillo(num_pag:int, paginas_anteriores: tuple[int, int])-&gt;tuple[int, int]:\n    '''M\u00e9todo program\u00e1tico para obtener p\u00e1ginas del cuadernillo que se est\u00e1n\n    procesando en la imagen actualmente abierta. Dado que siempre una p\u00e1gina tiene preguntas\n    que vienen en orden ascendente y la otra en orden descendente (por la l\u00f3gica de cuadernillo), se incorpora\n    esto en el algoritmo. Se actualiza en cada iteraci\u00f3n del loop.\n\n    Examples:\n        &gt;&gt;&gt; get_paginas_actuales_cuadernillo(3, (10, 3))\n        (4, 9)\n\n    Args:\n        num_pag: n\u00famero de imagen del cuadernillo que se est\u00e1 procesando. Parte en 0.\n\n        paginas_anteriores: tupla que contiene p\u00e1ginas del cuadernillo en la iteraci\u00f3n anterior.\n            Ejemplo: (10,3) para la p\u00e1gina 2 del cuadernillo estudiantes 2023\n\n\n    Returns:\n        paginas_actuales: tupla actualizada con p\u00e1ginas del cuadernillo siendo procesadas actualmente\n\n\n    '''\n\n    if num_pag == 0:\n        paginas_actuales = paginas_anteriores\n    # si num_pag es par y no es la primera p\u00e1gina\n    elif (num_pag % 2 == 0):\n        paginas_actuales = (paginas_anteriores[1]-1, paginas_anteriores[0] + 1)\n    elif num_pag % 2 == 1:\n        paginas_actuales = (paginas_anteriores[1]+1, paginas_anteriores[0] - 1)\n\n    return paginas_actuales\n</code></pre>"},{"location":"generar_insumos_img/#simce.generar_insumos_img.get_preg_por_hoja","title":"<code>get_preg_por_hoja(n_pages, n_preguntas, directorio_imagenes, args, nivel='cuadernillo')</code>","text":"<p>Puebla diccionario completo que mapea preguntas del cuestionario a su hoja o imagen correspondiente en el cuadernillo. Utiliza como insumo el n\u00famero de p\u00e1ginas del cuadernillo y el n\u00b0 de preguntas del cuestionario.</p> <p>Parameters:</p> Name Type Description Default <code>n_pages</code> <code>int</code> <p>n\u00famero de p\u00e1ginas del cuadernillo</p> required <code>n_preguntas</code> <code>int</code> <p>n\u00famero de preguntas del cuadernillo</p> required <code>directorio_imagenes</code> <code>PathLike</code> <p>directorio donde se encuentran im\u00e1genes del tipo de cuadernillo que se est\u00e1 procesando (padres o estudiantes).</p> required <code>nivel</code> <code>str</code> <p>indica si se est\u00e1 obteniendo diccionario a nivel cuadernillo o p\u00e1gina.</p> <code>'cuadernillo'</code> <p>Returns:</p> Name Type Description <code>diccionario_nivel</code> <code>dict</code> <p>diccionario donde las llaves son cada una de las preguntas del cuadernillo y los  valores son el n\u00b0 de p\u00e1gina o imagen que le corresponde, seg\u00fan si nivel es \"p\u00e1gina\" o \"cuadernillo\", respectivamente.</p> Source code in <code>simce\\generar_insumos_img.py</code> <pre><code>def get_preg_por_hoja(n_pages:int, n_preguntas:int,\n                       directorio_imagenes:os.PathLike, args:argparse.Namespace,\n                         nivel:str='cuadernillo'\n                         )-&gt;dict:\n    '''Puebla diccionario completo que mapea preguntas del cuestionario a su hoja o imagen\n    correspondiente en el cuadernillo. Utiliza como insumo el n\u00famero de p\u00e1ginas del cuadernillo y el n\u00b0\n    de preguntas del cuestionario.\n\n\n    Args:\n        n_pages: n\u00famero de p\u00e1ginas del cuadernillo\n\n        n_preguntas: n\u00famero de preguntas del cuadernillo\n\n        directorio_imagenes: directorio donde se encuentran im\u00e1genes del tipo de\n            cuadernillo que se est\u00e1 procesando (padres o estudiantes).\n\n        nivel: indica si se est\u00e1 obteniendo diccionario a nivel cuadernillo o p\u00e1gina.\n\n\n    Returns:\n        diccionario_nivel: diccionario donde las llaves son cada una de las preguntas del cuadernillo y los \n            valores son el n\u00b0 de p\u00e1gina o imagen que le corresponde, seg\u00fan si nivel es \"p\u00e1gina\" o \"cuadernillo\",\n            respectivamente.\n\n\n    '''\n\n    if nivel not in proc.VALID_INPUT:\n        raise ValueError(f\"nivel debe ser uno de los siguientes valores: {proc.VALID_INPUT}\")\n\n    primer_est = re.search(\n        f'({regex_estudiante})',\n        # primer estudiante del primer rbd:\n        str(next(next(directorio_imagenes.iterdir()).iterdir()))).group(1)\n\n    diccionario_nivel = generar_diccionarios_x_pagina(n_pages, n_preguntas, directorio_imagenes,\n                                    filter_estudiante=primer_est, nivel=nivel, args=args,\n                                    ignorar_primera_pagina=IGNORAR_PRIMERA_PAGINA)\n    return diccionario_nivel\n</code></pre>"},{"location":"generar_insumos_img/#simce.generar_insumos_img.get_recuadros_x_subpreg","title":"<code>get_recuadros_x_subpreg(value)</code>","text":"<p>Extrae de las celdas el n\u00famero de opciones posibles en cada pregunta. Se excluyen del string las opciones     Vac\u00edo y doble marca, que no representan recuadros en la pr\u00e1ctica.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; get_recuadros_x_subpreg(\n\"0: vacio\n1: Nada capaz\n2: Poco capaz\n3: Bastante capaz\n4: Muy capaz\n99: doble marca\")\n4\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>string de la celda que contiene valores posibles de subpregunta, proveniente de Excel</p> required <p>Returns:</p> Name Type Description <code>n_recuadros_x_subpreg</code> <code>int</code> <p>N\u00b0 de recuadros en subpregunta para la que se est\u00e1 calculando.</p> Source code in <code>simce\\generar_insumos_img.py</code> <pre><code>def get_recuadros_x_subpreg(value: str)-&gt;int:\n    '''Extrae de las celdas el n\u00famero de opciones posibles en cada pregunta. Se excluyen del string las opciones\n        Vac\u00edo y doble marca, que no representan recuadros en la pr\u00e1ctica.\n\n    Examples:\n        &gt;&gt;&gt; get_recuadros_x_subpreg(\n        \"0: vacio\n        1: Nada capaz\n        2: Poco capaz\n        3: Bastante capaz\n        4: Muy capaz\n        99: doble marca\")\n        4\n\n    Args:\n        value: string de la celda que contiene valores posibles de subpregunta, proveniente de Excel\n\n    Returns:\n        n_recuadros_x_subpreg: N\u00b0 de recuadros en subpregunta para la que se est\u00e1 calculando. \n\n    '''\n    list_valores = value.split('\\n')\n\n    n_recuadros_x_subpreg = len([i for i in list_valores if not re.search('(vac[i\u00ed]o)|99', i, re.IGNORECASE)])\n\n    return n_recuadros_x_subpreg\n</code></pre>"},{"location":"generar_insumos_img/#simce.generar_insumos_img.get_subpreg_x_preg","title":"<code>get_subpreg_x_preg(df_preguntas)</code>","text":"<p>Funci\u00f3n que puebla diccionario que mapea para cada pregunta, cu\u00e1ntas subpreguntas tiene asociada.</p> <p>Parameters:</p> Name Type Description Default <code>df_preguntas</code> <code>DataFrame</code> <p>DataFrame en que cada celda es una subpregunta para un SIMCE espec\u00edfico.</p> required <p>Returns:</p> Name Type Description <code>subpreg_x_preg</code> <code>dict</code> <p>diccionario donde las llaves son cada una de las preguntas del cuadernillo y los  valores son el n\u00b0 de subpreguntas asociados a esa pregunta.</p> Source code in <code>simce\\generar_insumos_img.py</code> <pre><code>def get_subpreg_x_preg(df_preguntas: pd.DataFrame)-&gt; dict:\n    '''Funci\u00f3n que puebla diccionario que mapea para cada pregunta, cu\u00e1ntas subpreguntas tiene asociada.\n\n\n    Args:\n        df_preguntas: DataFrame en que cada celda es una subpregunta para un SIMCE espec\u00edfico.\n\n\n    Returns:\n        subpreg_x_preg: diccionario donde las llaves son cada una de las preguntas del cuadernillo y los \n            valores son el n\u00b0 de subpreguntas asociados a esa pregunta.\n\n\n    '''\n\n    df_preguntas['preg'] = df_preguntas[nombre_col_campo_bd].str.extract(r'^p(\\d+)').astype(int)\n    subpreg_x_preg = df_preguntas['preg'].value_counts().sort_index()\n    subpreg_x_preg.index = 'p' + subpreg_x_preg.index.astype('string') \n    subpreg_x_preg = subpreg_x_preg.to_dict()\n    return subpreg_x_preg\n</code></pre>"},{"location":"generar_insumos_img/#simce.generar_insumos_img.poblar_diccionario_preguntas","title":"<code>poblar_diccionario_preguntas(q, dic_paginas, nivel='cuadernillo', dir_pag=None, page=None)</code>","text":"<p>Funci\u00f3n va poblando un diccionario que, para cada pregunta del cuestionario, indica a qu\u00e9 p\u00e1gina del cuadernillo pertenece o a qu\u00e9 imagen pertenece, si el nivel es p\u00e1gina o cuadernillo, respectivamente.</p> <p>Por ejemplo, si usamos el diccionario de estudiantes 2023, buscamos el valor asociado a p21, nos dir\u00e1 que esta se encuentra en la imagen 3 del cuadernillo (nivel cuadernillo) o en la p\u00e1gina 10 del cuadernillo (nivel p\u00e1gina).</p> <p>Parameters:</p> Name Type Description Default <code>q</code> <code>int</code> <p>pregunta siendo poblada actualmente en el diccionario. Por ejemplo, 2, 14.</p> required <code>dic_paginas</code> <code>dict</code> <p>diccionario siendo poblado, puede ser a nivel de cuadernillo (imagen) o de p\u00e1gina del cuadernillo</p> required <code>nivel</code> <code>str</code> <p>nivel del diccionario que estamos poblando: cuadernillo o p\u00e1gina.</p> <code>'cuadernillo'</code> <code>dir_pag</code> <code>None | PathLike</code> <p>directorio de imagen siendo procesada actualmente (solo se usa si es a                                                                        nivel cuadernillo)</p> <code>None</code> <code>page</code> <code>int | None</code> <p>p\u00e1gina del cuadernillo siendo procesada actualmente (solo se usa si es a nivel p\u00e1gina)</p> <code>None</code> <p>Returns:</p> Name Type Description <code>dic_paginas</code> <code>dict</code> <p>diccionario actualizado con la pregunta q.</p> Source code in <code>simce\\generar_insumos_img.py</code> <pre><code>def poblar_diccionario_preguntas(q: int, dic_paginas:dict, nivel:str='cuadernillo',\n                                 dir_pag:None|os.PathLike=None, page:int|None=None)-&gt;dict:\n    '''Funci\u00f3n va poblando un diccionario que, para cada pregunta del cuestionario, indica a qu\u00e9 p\u00e1gina\n    del cuadernillo pertenece o a qu\u00e9 imagen pertenece, si el nivel es p\u00e1gina o cuadernillo,\n    respectivamente.\n\n    Por ejemplo, si usamos el diccionario de estudiantes 2023, buscamos el valor asociado a p21, nos dir\u00e1\n    que esta se encuentra en la imagen 3 del cuadernillo (nivel cuadernillo) o en la p\u00e1gina 10 del\n    cuadernillo (nivel p\u00e1gina).\n\n    Args:\n        q: pregunta siendo poblada actualmente en el diccionario. Por ejemplo, 2, 14.\n\n        dic_paginas: diccionario siendo poblado, puede ser a nivel de cuadernillo (imagen) o de\n            p\u00e1gina del cuadernillo\n\n        nivel: nivel del diccionario que estamos poblando: cuadernillo o p\u00e1gina.\n\n        dir_pag: directorio de imagen siendo procesada actualmente (solo se usa si es a\n                                                                                   nivel cuadernillo)\n\n        page: p\u00e1gina del cuadernillo siendo procesada actualmente (solo se usa si es a nivel p\u00e1gina)\n\n    Returns:\n        dic_paginas: diccionario actualizado con la pregunta q.\n\n\n    '''\n\n    if nivel == 'cuadernillo':\n        # print(dir_pag)\n        hoja_cuadernillo = re.search(regex_hoja_cuadernillo, dir_pag.name).group(1)\n        dic_paginas[f'p{q}'] = hoja_cuadernillo\n    elif nivel == 'pagina':\n        dic_paginas[f'p{q}'] = page\n\n    return dic_paginas\n</code></pre>"},{"location":"indicadores_tinta/","title":"Indicadores de tinta","text":"<p>En este manual se repasan las funciones asociadas al c\u00e1lculo de indicadores en torno a la tinta en recuadros de respuesta, que se realiza posterior a la  predicci\u00f3n de dobles marcas </p>"},{"location":"indicadores_tinta/#simce.indicadores_tinta.calcular_indices_tinta","title":"<code>calcular_indices_tinta(ruta)</code>","text":"<p>Calcula \u00edndices de tinta para una subpregunta espec\u00edfica.</p> <p>Parameters:</p> Name Type Description Default <code>ruta</code> <code>str | PathLike</code> <p>ruta de la imagen a la que se le calcular\u00e1n los indicadores</p> required <p>Returns:</p> Name Type Description <code>indices_relevantes</code> <code>list[float, float]</code> <p>lista con indicador de porcentaje de tinta de primer y segundo recuadros m\u00e1s altos.</p> <code>intensidades_relevantes</code> <code>list[float, float]</code> <p>lista con indicador de intensidad de tinta de primer y segundo recuadros m\u00e1s altos.</p> Source code in <code>simce\\indicadores_tinta.py</code> <pre><code>def calcular_indices_tinta(ruta:str|PathLike)-&gt; tuple[list[float, float], list[float, float]]:\n    \"\"\"\n    Calcula \u00edndices de tinta para una subpregunta espec\u00edfica.\n\n    Args:\n        ruta: ruta de la imagen a la que se le calcular\u00e1n los indicadores\n\n    Returns:\n        indices_relevantes: lista con indicador de porcentaje de tinta de primer y segundo recuadros m\u00e1s altos.\n\n        intensidades_relevantes: lista con indicador de intensidad de tinta de primer y segundo recuadros m\u00e1s altos.\n\n    \"\"\"\n\n    bordered_mask, bordered_rect_img = preparar_mascaras(ruta)\n\n    contours, _ = cv2.findContours(bordered_mask, cv2.RETR_LIST, cv2.CHAIN_APPROX_SIMPLE)\n\n    big_contours = [\n        i for i in contours if 250 &lt; cv2.contourArea(i) &lt; 2600 ]\n    #bgr_img = cv2.imread(ruta)[20:-20, 15:-15]\n\n\n    porcentajes_tinta = []\n    intensidades = []\n\n    for contour in big_contours:\n        x, y, w, h = cv2.boundingRect(contour)\n        # Ajustamos x y h, porque transformaciones est\u00e1n generando recuadros m\u00e1s peque\u00f1os\n        x = x - 3\n        y = y - 3\n\n        ratio_dims = w / h\n        if ratio_dims &gt; 5 or ratio_dims &lt; .2:\n            continue\n\n        elif  ratio_dims &gt; 1.15 or ratio_dims &lt; .85:\n            dif_px = np.abs(w - h) \n            px_cortar = int(np.floor(dif_px/2))\n            # Si el ratio es mayor a 1, el recuadro es m\u00e1s ancho de lo que deber\u00eda:\n            if ratio_dims &gt; 1:   \n                w = w - px_cortar\n                x = x - px_cortar\n            # Si el ratio es menor a 1, el recuadro es m\u00e1s alto de lo que deber\u00eda:\n            else:\n                h = h - px_cortar\n                y = y + px_cortar\n\n        #cv2.rectangle(bordered_rect_img, (x, y), (x+w, y+h), 0, 3)\n        img_crop = bordered_rect_img[y+3:y+h-3, x+3:x+w-3]\n        idx_blanco = np.where(img_crop &gt; 0.9)\n        img_crop[idx_blanco] = 1\n\n\n        intensidad_promedio = 1- img_crop[img_crop != 1].mean()\n        indice = 1 - img_crop.mean()\n        porcentajes_tinta.append(np.round(indice, 3))\n        intensidades.append(np.round(intensidad_promedio, 3))\n\n\n\n\n    porcentajes_relevantes = sorted(porcentajes_tinta, reverse = True)[:2]\n    intensidades_relevantes =   sorted([i for i in intensidades if not pd.isna(i)], reverse = True)[:2]\n\n    return porcentajes_relevantes, intensidades_relevantes\n</code></pre>"},{"location":"indicadores_tinta/#simce.indicadores_tinta.get_indices_tinta_total","title":"<code>get_indices_tinta_total(dirs)</code>","text":"<p>Toma tabla de predicciones y procede a calcular \u00edndices de tinta, que agrega a la tabla y luego exporta una tabla final. Los indicadores calculados son:</p> <ul> <li> <p>Ratio porcentaje de tinta: ratio entre el porcentaje relleno del recuadro con m\u00e1s tinta     y el segundo recuadro con m\u00e1s tinta, para una subpregunta dada</p> </li> <li> <p>Ratio de intensidad de tinta: ratio entre la intensidad promedio de la tinta del recuadro m\u00e1s intenso    y el segundo m\u00e1s intenso, para una subpregunta dada</p> </li> </ul> <p>No retorna nada</p> <p>Parameters:</p> Name Type Description Default <code>dirs</code> <code>dict[str, PathLike]</code> <p>diccionario de directorios del proyecto</p> required Source code in <code>simce\\indicadores_tinta.py</code> <pre><code>def get_indices_tinta_total(dirs: dict[str, PathLike]):\n    \"\"\"\n    Toma tabla de predicciones y procede a calcular \u00edndices de tinta, que agrega a la tabla y luego\n    exporta una tabla final. Los indicadores calculados son:\n\n      - Ratio porcentaje de tinta: ratio entre el porcentaje relleno del recuadro con m\u00e1s tinta\n        y el segundo recuadro con m\u00e1s tinta, para una subpregunta dada\n\n      - Ratio de intensidad de tinta: ratio entre la intensidad promedio de la tinta del recuadro m\u00e1s intenso \n      y el segundo m\u00e1s intenso, para una subpregunta dada\n\n    **No retorna nada**\n\n    Args:\n        dirs: diccionario de directorios del proyecto\n\n\n    \"\"\"\n    preds = pd.read_parquet(dirs['dir_predicciones'] / 'predicciones_modelo.parquet')\n    preds['indices'] = preds.ruta_imagen_output.apply(lambda x: calcular_indices_tinta(x))\n    preds = preds.reset_index(drop=True)\n    split = pd.DataFrame(preds['indices'].tolist(), columns = ['indice_tinta', 'indice_intensidad'])\n    preds_final = preds.copy()\n    for col in split.columns:\n        col_split = pd.DataFrame(split[col].tolist(), columns = [f'{col}_top1', f'{col}_top2'])\n        preds_final = pd.concat([preds_final, col_split], axis = 1)\n    preds_final['ratio_tinta'] = preds_final.indice_tinta_top1 / preds_final.indice_tinta_top2\n    preds_final['ratio_intensidad'] = preds_final.indice_intensidad_top1 / preds_final.indice_intensidad_top2\n\n\n    preds_final.to_excel(dirs['dir_predicciones'] / 'predicciones_modelo_final.xlsx')\n\n    print('Predicciones con insumos posteriores exportadas exitosamente!')\n</code></pre>"},{"location":"indicadores_tinta/#simce.indicadores_tinta.get_recuadros","title":"<code>get_recuadros(mask_blanco)</code>","text":"<p>Detecta recuadros en imagen. Genera m\u00e1scara que intenta obtener todos los recuadros correspondientes a la subpregunta     siendo procesada. Es un insumo inicial que luego sigue siendo procesado a lo largo de la funci\u00f3n     preparar_mascaras. Esta funci\u00f3n basta para detectar la mayor\u00eda de recuadros, salvo cuando estos tienen     mucha tinta, haciendo desaparecer el color blanco.</p> <p>Parameters:</p> Name Type Description Default <code>mask_blanco</code> <code>ndarray</code> <p>m\u00e1scara que intenta identificar color blanco dentro de la imagen</p> required <p>Returns:</p> Name Type Description <code>bordered_mask</code> <code>ndarray</code> <p>m\u00e1scara procesada que intenta identificar recuadros dentro de la imagen. </p> <code>big_contours</code> <code>list[ndarray]</code> <p>contornos de recuadros. Son utilizados posteriormentes para marcarlos en la imagen.</p> Source code in <code>simce\\indicadores_tinta.py</code> <pre><code>def get_recuadros(mask_blanco: np.ndarray)-&gt;tuple[np.ndarray, list[np.ndarray]]:\n    \"\"\"Detecta recuadros en imagen. Genera m\u00e1scara que intenta obtener todos los recuadros correspondientes a la subpregunta\n        siendo procesada. Es un insumo inicial que luego sigue siendo procesado a lo largo de la funci\u00f3n\n        [preparar_mascaras](#preparar_mascaras). Esta funci\u00f3n basta para detectar la mayor\u00eda de recuadros, salvo cuando estos tienen\n        mucha tinta, haciendo desaparecer el color blanco.\n\n    Args:\n        mask_blanco: m\u00e1scara que intenta identificar color blanco dentro de la imagen\n\n    Returns:\n        bordered_mask: m\u00e1scara procesada que intenta identificar recuadros dentro de la imagen. \n\n        big_contours: contornos de recuadros. Son utilizados posteriormentes para marcarlos en la imagen.\n    \"\"\"    \n     # Define the border width in pixels\n    top, bottom, left, right = [3]*4\n\n    # Create a border around the image\n    bordered_mask = cv2.copyMakeBorder(mask_blanco, top, bottom, left, right,\n                                        cv2.BORDER_CONSTANT, value=0).astype(np.uint8)\n\n    contours, _ = cv2.findContours(bordered_mask, cv2.RETR_LIST, cv2.CHAIN_APPROX_SIMPLE)\n\n    big_contours = [\n        i for i in contours if 600 &lt; cv2.contourArea(i) &lt; 2000 ]\n\n\n    for contour in big_contours:\n        x, y, w, h = cv2.boundingRect(contour)\n\n        cv2.rectangle(bordered_mask, (x, y), (x+w, y+h), 255, -1)\n\n    kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (3,3))\n    bordered_mask2 = cv2.morphologyEx(bordered_mask, cv2.MORPH_CLOSE, kernel, iterations=3)\n\n\n    contours2, _ = cv2.findContours(bordered_mask2, cv2.RETR_LIST, cv2.CHAIN_APPROX_SIMPLE)\n\n    big_contours2 = [\n        i for i in contours2 if 600 &lt; cv2.contourArea(i) &lt; 2000 ]\n\n\n    for contour in big_contours2:\n        x, y, w, h = cv2.boundingRect(contour)\n\n        cv2.rectangle(bordered_mask2, (x, y), (x+w, y+h), 255, -1)\n\n    if len(big_contours2) &gt;= len(big_contours):\n\n        return bordered_mask2, big_contours2\n    else:\n\n        return bordered_mask, big_contours\n</code></pre>"},{"location":"indicadores_tinta/#simce.indicadores_tinta.preparar_mascaras","title":"<code>preparar_mascaras(ruta)</code>","text":"<p>Genera m\u00e1scaras que detectan recuadros de imagen, para posteriormente calcular indicadores de tinta en funci\u00f3n  calcular_indices_tinta.</p> <p>Parameters:</p> Name Type Description Default <code>ruta</code> <code>PathLike</code> <p>ruta de imagen a leer para obtener m\u00e1scara</p> required <p>Returns:</p> Name Type Description <code>bordered_mask</code> <code>ndarray</code> <p>m\u00e1scara con detecci\u00f3n de contornos.</p> <code>bordered_rect_img</code> <code>ndarray</code> <p>imagen a la que se le calcular\u00e1n los indicadores.</p> Source code in <code>simce\\indicadores_tinta.py</code> <pre><code>def preparar_mascaras(ruta: PathLike)-&gt; tuple[np.ndarray, np.ndarray]:\n    \"\"\"Genera m\u00e1scaras que detectan recuadros de imagen, para posteriormente calcular indicadores de tinta en funci\u00f3n \n    [calcular_indices_tinta](#calcular_indices_tinta).\n\n    Args:\n        ruta: ruta de imagen a leer para obtener m\u00e1scara\n\n    Returns:\n        bordered_mask: m\u00e1scara con detecci\u00f3n de contornos.\n\n        bordered_rect_img: imagen a la que se le calcular\u00e1n los indicadores.\n    \"\"\"    \n\n    bgr_img = cv2.imread(ruta)\n\n    mask_blanco = get_mask_imagen(bgr_img, lower_color=np.array([0,31,0]),\n                                  upper_color=np.array([179, 255, 255]), iters=1,\n                                    eliminar_manchas=False, revert=True)\n\n    mask_blanco_fill, contornos_og = get_recuadros(mask_blanco)\n\n    if 'CE' in ruta:\n        # Detectamos grises y negros si es cuestionario de estudiantes\n        mask_tinta = get_mask_imagen(bgr_img, lower_color=np.array([0,0,225]),\n                                    upper_color=np.array([179, 255, 255]), iters=1, eliminar_manchas=False,\n                                    revert=True)\n\n    elif 'CP' in ruta:\n        # Detectamos tinta azul si es cuestionario de padres\n        mask_tinta = get_mask_imagen(bgr_img, lower_color=np.array([67,46,0]),\n                                    upper_color=np.array([156, 255, 255]), iters=1, eliminar_manchas=False)\n        if mask_tinta.mean() &lt; 0.7:\n            # Detectamos grises y negros si no detectamos tinta azul\n            mask_tinta = get_mask_imagen(bgr_img, lower_color=np.array([0,0,225]),\n                                        upper_color=np.array([179, 255, 255]), iters=1, eliminar_manchas=False,\n                                        revert=True)\n\n\n    kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (3,3))\n    mask_tinta = cv2.morphologyEx(mask_tinta, cv2.MORPH_CLOSE, kernel, iterations=2)\n\n    kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (2,2))\n    mask_tinta = cv2.erode(mask_tinta, kernel, iterations=1)\n\n    idx_blanco = np.where(mask_tinta == 255)\n    mask_blanco_fill[idx_blanco] = 255\n\n    kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (3,3))\n    mask_blanco_fill = cv2.morphologyEx(mask_blanco_fill, cv2.MORPH_CLOSE, kernel, iterations=2)\n\n\n    axis = 0\n    # Calculamos la media de cada columna:\n    sum_blanco = np.sum(mask_blanco_fill == 255, axis=axis)\n\n    # Si la media es menor a 100, reemplazamos con 0 (negro):\n    # Esto permite eliminar manchas de color que a veces se dan\n    idx_low_rows = np.where(sum_blanco &lt; 12)[0]\n    mask_blanco_fill[:, idx_low_rows] = 0\n\n    # Creo contorno en torno a contornos originales, para no distorsionar\n    for contour in contornos_og:\n        x, y, w, h = cv2.boundingRect(contour)\n\n        cv2.rectangle(mask_blanco_fill, (x, y), (x+w, y+h), 0, 4)\n\n\n    # Define the border width in pixels\n    top, bottom, left, right = [3]*4\n\n    # Create a border around the image\n    bordered_mask = cv2.copyMakeBorder(mask_blanco_fill, top, bottom, left, right,\n                                        cv2.BORDER_CONSTANT, value=0).astype(np.uint8)\n    rect_img = cv2.cvtColor(bgr_img,cv2.COLOR_BGR2GRAY) /255\n    #bordered_mask = cv2.bitwise_not(bordered_mask)\n\n    bordered_rect_img = cv2.copyMakeBorder(rect_img, top, bottom, left, right, cv2.BORDER_CONSTANT, value=1)\n\n    return bordered_mask, bordered_rect_img\n</code></pre>"},{"location":"outputs/","title":"Gu\u00eda de outputs del proyecto","text":"<p>En esta secci\u00f3n encontrar\u00e1s una descripci\u00f3n del contenido de los archivos generados en los procesos get_recortes.py y get_predicciones.py.</p>"},{"location":"outputs/#problemas_imagenesxlsx","title":"problemas_imagenes.xlsx","text":"<p>Este archivo se genera al terminar el proceso de get_recortes.py, el cual nos indica las preguntas que tuvieron un problema en la obtenci\u00f3n del recorte. Esta tabla se compone de 3 columnas, las cuales se describen a continuaci\u00f3n:</p> Columna Descripci\u00f3n Pregunta Ruta de la imagen que no pudo ser procesada. Error Detalle del error generado en el procesamiento. Esto puede ser por errores de carga, n\u00famero incorrecto de subpreguntas, errores al detectar l\u00edneas o recuadros, entre otras. Nivel Nivel del error, el cual puede ser a nivel de pregunta, subpregunta, estudiantes o padres (usado principalmente para debuggear problemas en los c\u00f3digos del flujo)."},{"location":"outputs/#predicciones_modelo_finalxlsx","title":"predicciones_modelo_final.xlsx","text":"<p>Este archivo se genera al terminar el proceso de get_predicciones.py. Aqu\u00ed encontraremos las predicciones del modelo de detecci\u00f3n de dobles marcas y los indices de tinta que se identificaron para cada pregunta/subpregunta. Este archivo se compone por 18 columnas, en donde 9 corresponden a la informaci\u00f3n predicha por el modelo y los indices de tinta, los cuales describiremos a continuaci\u00f3n:</p> Columna Descripci\u00f3n pred Etiqueta de la predicci\u00f3n obtenida, en donde 1 nos indica que la pregunta/subpregunta corresponde a una doble marca y 0 que no es doble marca. proba Probabilidad de la etiqueta. Nos indica que tan seguro est\u00e1 el modelo de su etiqueta predicha, mientras m\u00e1s cercano a 1, m\u00e1s seguro esta el modelo de su decisi\u00f3n. Por otro lado, mientras m\u00e1s cercano a 0.5, menos seguro estar\u00e1 el modelo de la etiqueta indicada. indices Tupla de valores que nos indican el porcentaje e intensidad promedio de tinta presente en los dos recuadros con mayores valores. indice_tinta_top1 Porcentaje de tinta promedio del recuadro con mayor valor. indice_tinta_top2 Porcentaje de tinta promedio del segundo recuadro con mayor valor. indice_intensidad_top1 Intensidad de tinta promedio del recuadro con mayor valor. indice_intensidad_top2 Intensidad de tinta promedio del segundo recuadro con mayor valor. ratio_tinta Raz\u00f3n entre el porcentaje medio de tinta presente en los dos recuadros con m\u00e1s tinta (indice_tinta_top1/indice_tinta_top2). Si el valor es 1, nos indica que los dos recuadros evaluados poseen la misma cantidad de tinta rellana en el recuadro. ratio_intensidad Raz\u00f3n entre la intensidad media de tinta presente en los dos recuadros con mayor tinta (indice_intensidad_top1/indice_intensidad_top2). Si el valor es 1, nos indica que los dos recuadros poseen la misma intensidad de trazos realizados en el recuadro <p>Las 9 columnas faltantes nos ayudan a describir la pregunta/subrepgunta analizada (ubicaci\u00f3n directorio, serie, rbd, CodigoCurso, entre otras).</p>"},{"location":"paralelizacion/","title":"Procesamiento paralelizado","text":"<p>En este manual se repasan las funciones asociadas al procesamiento  paralelizado de las im\u00e1genes que permite su recorte utilizando los n\u00facleos disponibles de la m\u00e1quina. Aqu\u00ed se produce el procesamiento de im\u00e1genes en la pr\u00e1ctica, pero se llaman las funciones que de la secci\u00f3n de recorte de subpreguntas. </p>"},{"location":"paralelizacion/#simce.paralelizacion.process_general","title":"<code>process_general(dirs, regex_estudiante, queue, curso, tipo_cuadernillo, args, filter_rbd=None, filter_estudiante=None)</code>","text":"<p>Genera el recorte de preguntas/subpreguntas, de forma paralelizada, para los registros obtenidos de la      funci\u00f3n que genera tabla de im\u00e1genes con dobles marcas.     Para ello, se utilizan los insumos generados en     la funci\u00f3n de obtenci\u00f3n de insumos,     se cuenta      el total de CPUs para realizar el procesamiento simult\u00e1neo, se dividen las preguntas equitativamente     para que cada n\u00facleo posea aproximadamente la misma cantidad de preguntas a recortar, y finalmente     se aplica la funci\u00f3n que procesa bloque de im\u00e1genes       para realizar el procesamiento de cada pregunta en los diferentes      bloques disponibles (se le aplica la misma funcion de procesamiento en cada uno de los bloques).     No retorna nada.</p> <p>Parameters:</p> Name Type Description Default <code>dirs</code> <code>dict[str, PathLike]</code> <p>Diccionario con los directorios a usar</p> required <code>regex_estudiante</code> <code>str</code> <p>Expresion regular que nos ayuda a identificar el n\u00b0 de serie del cuestionario </p> required <code>queue</code> <code>Queue</code> <p>Cola de tareas gestionada por Manager() para intercambiar datos entre procesos de forma segura.</p> required <code>curso</code> <code>str</code> <p>Nombre carpeta que identifica el curso en procesamiento.</p> required <code>tipo_cuadernillo</code> <code>str</code> <p>define si se est\u00e1 procesando para estudiantes o padres. Esto tambi\u00e9n se utiliza para definir las rutas a consultar</p> required <code>args</code> <code>Namespace</code> <p>argumentos enviados desde la l\u00ednea de comandos.</p> required <code>filter_rbd</code> <code>None | str | list[str]</code> <p>permite filtrar uno o m\u00e1s RBDs espec\u00edficos y solo realizar la operaci\u00f3n sobre estos.</p> <code>None</code> <code>filter_estudiante</code> <code>None | str | list[str]</code> <p>permite filtrar uno o m\u00e1s estudiantes espec\u00edficos y solo realizar la operaci\u00f3n sobre estos.</p> <code>None</code> Source code in <code>simce\\paralelizacion.py</code> <pre><code>@timing\ndef process_general(dirs:dict[str, PathLike], regex_estudiante: str, queue:Queue, curso: str, tipo_cuadernillo: str,\n                    args:argparse.Namespace, filter_rbd: None|str|list[str]= None, \n                    filter_estudiante: None|str|list[str]= None):\n\n    \"\"\"\n    Genera el recorte de preguntas/subpreguntas, de forma paralelizada, para los registros obtenidos de la \n        [funci\u00f3n que genera tabla de im\u00e1genes con dobles marcas](../proc_tabla_99#simce.proc_tabla_99.get_tablas_99).\n        Para ello, se utilizan los insumos generados en\n        la [funci\u00f3n de obtenci\u00f3n de insumos](../generar_insumos_img#simce.generar_insumos_img.generar_insumos),\n        se cuenta \n        el total de CPUs para realizar el procesamiento simult\u00e1neo, se dividen las preguntas equitativamente\n        para que cada n\u00facleo posea aproximadamente la misma cantidad de preguntas a recortar, y finalmente\n        se aplica la [funci\u00f3n que procesa bloque de im\u00e1genes](../paralelizacion#simce.paralelizacion.process_image_block)\n          para realizar el procesamiento de cada pregunta en los diferentes \n        bloques disponibles (se le aplica la misma funcion de procesamiento en cada uno de los bloques).\n        **No retorna nada**.\n\n    Args:\n        dirs: Diccionario con los directorios a usar\n\n        regex_estudiante: Expresion regular que nos ayuda a identificar el n\u00b0 de serie del cuestionario \n\n        queue: Cola de tareas gestionada por Manager() para intercambiar datos entre procesos de forma segura.\n\n        curso: Nombre carpeta que identifica el curso en procesamiento.\n\n        tipo_cuadernillo: define si se est\u00e1 procesando para estudiantes o padres. Esto tambi\u00e9n se utiliza para definir las rutas a consultar\n        args: argumentos enviados desde la l\u00ednea de comandos.\n\n        filter_rbd: permite filtrar uno o m\u00e1s RBDs espec\u00edficos y solo realizar la operaci\u00f3n sobre estos.\n\n        filter_estudiante: permite filtrar uno o m\u00e1s estudiantes espec\u00edficos y solo realizar la operaci\u00f3n sobre estos.\n\n    \"\"\"\n\n\n    print(f'Procesando cuadernillo {tipo_cuadernillo}')\n\n\n\n    nombre_tabla_casos99 = f'casos_99_compilados_{curso}_{tipo_cuadernillo}.csv'\n    df99 = pd.read_csv(dirs['dir_tabla_99'] / nombre_tabla_casos99, dtype={'rbd_ruta': 'string'}).sort_values('ruta_imagen')\n\n\n\n    if filter_rbd:\n\n        df99 = df99[(df99.rbd_ruta.isin(filter_rbd))]\n\n    if filter_estudiante:\n        if isinstance(filter_estudiante, int):\n            filter_estudiante = [filter_estudiante]\n        df99 = df99[df99.serie.isin(filter_estudiante)]\n\n    df99.ruta_imagen = df99.ruta_imagen.str.replace('\\\\', '/')\n    dir_preg99 = [dirs['dir_img_bruta'] / i for i in df99.ruta_imagen]\n\n    n_pages, _, subpreg_x_preg, _, dic_pagina, _ = get_insumos(tipo_cuadernillo,\n                                                                dir_insumos=dirs['dir_insumos'])\n\n    # Dividir en bloques para procesamiento paralelo\n    num_workers = cpu_count() -1\n    print('###########')\n    print(f'Cantidad de CPUs a usar {num_workers}')\n    print('###########')\n\n    block_size = len(dir_preg99) // num_workers\n    print(f'## Cantidad de preguntas en cada bloque: {block_size}')\n\n    image_blocks = [(queue, df99[i:i + block_size].preguntas, dir_preg99[i:i + block_size], dic_pagina, n_pages, \n                     subpreg_x_preg, dirs['dir_subpreg'], tipo_cuadernillo, regex_estudiante, args) for i in range(0, len(dir_preg99), block_size)]\n\n    # Usar multiprocessing Pool\n    with Pool(num_workers) as pool:\n        print('-------------')\n        pool.map(process_image_block, image_blocks)\n\n    print('\u00c9xito!')\n</code></pre>"},{"location":"paralelizacion/#simce.paralelizacion.process_image_block","title":"<code>process_image_block(image_block)</code>","text":"<p>Env\u00eda a cada bloque la funci\u00f3n process_single_image(), la que se encarga de realizar los recortes a cada una de las im\u00e1genes disponibles en los bloques. No retorna nada</p> <p>Parameters:</p> Name Type Description Default <code>image_block</code> <code>list</code> <p>lista con los objetos a usar en cada uno de los bloques, posee los insumos,  path de las imagenes y queue.</p> required Source code in <code>simce\\paralelizacion.py</code> <pre><code>def process_image_block(image_block:list):\n    \"\"\"\n    Env\u00eda a cada bloque la funci\u00f3n [process_single_image()](../paralelizacion#simce.paralelizacion.process_single_image),\n    la que se encarga de realizar los recortes a cada una de las im\u00e1genes disponibles en los bloques. **No retorna nada**\n\n    Args:\n        image_block: lista con los objetos a usar en cada uno de los bloques, posee los insumos, \n            path de las imagenes y queue.\n\n    \"\"\"\n    queue, preguntas, directorio_imagenes, dic_pagina, n_pages, \\\n          subpreg_x_preg, dir_subpreg, tipo_cuadernillo, regex_estudiante, args = image_block\n\n    for num, rbd in enumerate(directorio_imagenes):\n        process_single_image(preguntas, num, rbd, dic_pagina, n_pages,\n                             subpreg_x_preg, dir_subpreg, tipo_cuadernillo, regex_estudiante, args,\n                             queue)\n</code></pre>"},{"location":"paralelizacion/#simce.paralelizacion.process_single_image","title":"<code>process_single_image(preguntas, num, rbd, dic_pagina, n_pages, subpreg_x_preg, dir_subpreg, tipo_cuadernillo, regex_estudiante, args, queue)</code>","text":"<p>Genera el recorte de una pregunta/subpregunta. Primero se verifica que la imagen no posea franjas negras en ning\u00fan costado del cuestionario. Posteriormente, se divide la imagen en dos p\u00e1ginas del cuadernillo y se selecciona la p\u00e1gina de la pregunta a recortar. En esta, se detectan los recuadros de las preguntas y se realiza un primer recorte seg\u00fan las coordenadas obtenidas. Luego se identifican los recuadros de respuesta y se vuelve a cortar la imagen.</p> <p>Si la pregunta seleccionada no posee subpreguntas, se obtiene el recorte de recuadros de respuesta  y se guarda la imagen.</p> <p>Si la pregunta seleccionada posee subpreguntas, se identifican las l\u00edneas horizontales separadoras de subpreguntas y se procede a guardar la imagen con la secci\u00f3n de la subpregunta de inter\u00e9s. </p> <p>No retorna nada</p> <p>Parameters:</p> Name Type Description Default <code>preguntas</code> <code>Series</code> <p>lista con preguntas a recortar</p> required <code>num</code> <code>int</code> <p>ID de pregunta a recortar</p> required <code>rbd</code> <code>PathLike</code> <p>Ruta de la pregunta a recortar</p> required <code>dic_pagina</code> <code>dict</code> <p>Diccionario con mapeo de preguntas en la p\u00e1gina del cuestionario</p> required <code>n_pages</code> <code>int</code> <p>Cantidad de p\u00e1ginas que posee el cuestionario en total</p> required <code>subpreg_x_preg</code> <code>dict</code> <p>Insumo con cantidad de subpreguntas por pregunta.</p> required <code>dir_subpreg</code> <code>PathLike</code> <p>Directorio general en donde se guardar\u00e1n las preguntas recortadas </p> required <code>tipo_cuadernillo</code> <code>str</code> <p>define si se est\u00e1 procesando para estudiantes o padres.</p> required <code>regex_estudiante</code> <code>str</code> <p>Expresi\u00f3n regular que nos ayuda a identificar el n\u00b0 de serie del cuestionario</p> required <code>queue</code> <code>Queue</code> <p>Cola de tareas gestionada por Manager() para intercambiar datos entre procesos de forma segura.</p> required Source code in <code>simce\\paralelizacion.py</code> <pre><code>def process_single_image(preguntas:pd.Series, num: int, rbd:PathLike, dic_pagina:dict,\n                          n_pages: int, subpreg_x_preg: dict, \n                         dir_subpreg:PathLike, tipo_cuadernillo:str, regex_estudiante:str, \n                         args:argparse.Namespace, queue:Queue):\n\n    \"\"\"\n    Genera el recorte de una pregunta/subpregunta. Primero se verifica que la imagen no posea franjas negras en\n    ning\u00fan costado del cuestionario. Posteriormente, se divide la imagen en dos p\u00e1ginas del cuadernillo y\n    se selecciona la p\u00e1gina de la pregunta a recortar. En esta, se detectan los recuadros de las preguntas y\n    se realiza un primer recorte seg\u00fan las coordenadas obtenidas. Luego se identifican los recuadros de respuesta y\n    se vuelve a cortar la imagen.\n\n    Si la pregunta seleccionada no posee subpreguntas, se obtiene el recorte de recuadros de respuesta \n    y se guarda la imagen.\n\n    Si la pregunta seleccionada posee subpreguntas, se identifican las l\u00edneas horizontales separadoras de subpreguntas\n    y se procede a guardar la imagen con la secci\u00f3n de la subpregunta de inter\u00e9s. \n\n    **No retorna nada**\n\n    Args:\n        preguntas: lista con preguntas a recortar\n        num: ID de pregunta a recortar\n        rbd: Ruta de la pregunta a recortar\n        dic_pagina: Diccionario con mapeo de preguntas en la p\u00e1gina del cuestionario\n        n_pages: Cantidad de p\u00e1ginas que posee el cuestionario en total\n        subpreg_x_preg: Insumo con cantidad de subpreguntas por pregunta.\n        dir_subpreg: Directorio general en donde se guardar\u00e1n las preguntas recortadas \n        tipo_cuadernillo: define si se est\u00e1 procesando para estudiantes o padres.\n        regex_estudiante: Expresi\u00f3n regular que nos ayuda a identificar el n\u00b0 de serie del cuestionario\n        queue: Cola de tareas gestionada por Manager() para intercambiar datos entre procesos de forma segura.\n\n\n\n    \"\"\"\n    # from pathlib import Path\n    # df99 = df99[df99['serie'] == 4077894] #data\\input_raw\\CP\\02748\\4077894_4.jpg\n    # num = 1\n    # rbd = Path('data/input_raw/CP/02748/4077894_4.jpg')\n\n    pregunta_selec = re.search(r'p(\\d{1,2})', preguntas.iloc[num]).group(0)          # seleccion de pregunta\n    estudiante = re.search(f'({regex_estudiante})', str(rbd)).group(1)               # serie estudiante\n    pagina_pregunta = dic_pagina[pregunta_selec]                                     # ubicacion pregunta\n    pages = get_pages_cuadernillo(pagina_pregunta, n_pages)\n\n    dir_subpreg_rbd = (dir_subpreg /f'{rbd.parent.parent.name}'/ f'{rbd.parent.name}')  # obtencion path pregunta\n\n    dir_subpreg_rbd.mkdir(exist_ok=True, parents=True)\n\n    if not rbd.is_file():\n        preg_error = dir_subpreg_rbd / f'{estudiante}'\n        agregar_error(queue= queue,\n                      pregunta=str(preg_error),\n                      error=f'No existen archivos disponibles para serie {preg_error.name}',\n                      nivel_error=tipo_cuadernillo)\n        return 'Ocurri\u00f3 un error: archivo no existe'\n\n    file = rbd.name\n    if file not in files:\n        return ''\n\n    if args.verbose:\n        print(f'{file=}')\n    # Leemos imagen\n    img_completa = cv2.imread(str(rbd), 1) \n    img_completa_crop = recorte_imagen(img_completa, 0, 150, 50, 160)\n\n    # Eliminamos franjas negras en caso de existir\n    img_completa_sin_franja = eliminar_franjas_negras(img_completa_crop)\n\n    # Divimos imagen en dos p\u00e1ginas del cuadernillo\n    paginas_cuadernillo = partir_imagen_por_mitad(img_completa_sin_franja)\n\n    # Seleccionamos p\u00e1gina que nos interesa, basado en diccionario de p\u00e1ginas\n    media_img = paginas_cuadernillo[pages.index(pagina_pregunta)]\n\n    if media_img is None:\n        print(f\"Error: No se pudo cargar la imagen\")\n        agregar_error(queue= queue,\n                      pregunta=str(dir_subpreg_rbd / f'{estudiante}'),\n                      error=f'No se pudo cargar la mitad de la imagen',\n                      nivel_error=tipo_cuadernillo)\n\n        return 'Ocurri\u00f3 un error'\n\n    else:\n        # Detecto recuadros naranjos\n        try:\n            mask_naranjo = get_mask_imagen(media_img)\n\n            # Obtengo contornos\n            big_contours = get_contornos_grandes(mask_naranjo)\n\n            q_base = get_pregunta_inicial_pagina(dic_pagina, pagina_pregunta)\n            pregunta_selec_int = int(re.search(r'\\d+', pregunta_selec).group(0))\n\n            try:\n                # Obtengo coordenadas de contornos y corto imagen\n                elemento_img_pregunta = big_contours[pregunta_selec_int - q_base]\n                img_pregunta = bound_and_crop(media_img, elemento_img_pregunta)\n\n                img_recuadros_pregunta = dejar_solo_recuadros_subpregunta(img_pregunta)\n\n                # Exportamos pregunta si no tiene subpreguntas:\n                if subpreg_x_preg[pregunta_selec] == 1:\n                    save_pregunta_completa(img_recuadros_pregunta, dir_subpreg_rbd, estudiante, pregunta_selec)\n\n                    return '\u00c9xito!'\n\n                subpreg_selec = preguntas.iloc[num].split('_')[1]\n                if args.verbose:\n                    print(f'{subpreg_selec=}')\n\n                # Obtenemos subpreguntas:\n                #img_pregunta_crop = recorte_imagen(img_pregunta)\n                # img_crop_col = get_mask_imagen(img_pregunta_recuadros,\n                #                                lower_color=np.array(\n                #                                    [0, 111, 109]),\n                #                                upper_color=np.array([18, 255, 255]))\n\n                # Obtenemos lineas horizontales:\n                mask_lineas_horizontales = get_mascara_lineas_horizontales(img_recuadros_pregunta)\n\n                lineas_horizontales = obtener_lineas_horizontales(\n                    mask_lineas_horizontales, n_pixeles_entre_lineas=n_pixeles_entre_lineas,\n                      minLineLength=np.round(mask_lineas_horizontales.shape[1] * .6))\n                #print(lineas_horizontales)\n\n                n_subpreg = len(lineas_horizontales) - 1\n\n                if n_subpreg != subpreg_x_preg[pregunta_selec]:\n                    preg_error = str(dir_subpreg_rbd / f'{estudiante}')\n                    dic_dif = get_subpregs_distintas(subpreg_x_preg, dir_subpreg_rbd, estudiante)\n                    error = f'N\u00b0 de subpreguntas incorrecto para serie {estudiante}, se encontraron {n_subpreg} subpreguntas {dic_dif}'\n                    agregar_error(queue= queue, pregunta=preg_error, error=error, nivel_error=tipo_cuadernillo)\n\n                # Realizamos recorte y guardado de subpregunta\n                try:\n                    file_out = str(dir_subpreg_rbd / f'{estudiante}_{pregunta_selec}_{int(subpreg_selec)}.jpg')\n                    crop_and_save_subpreg(img_recuadros_pregunta, lineas_horizontales,\n                                          i=int(subpreg_selec)-1, file_out=file_out, verbose=args.verbose)\n\n                # Si hay error en procesamiento subpregunta\n                except Exception as e:\n                    print(e)\n                    preg_error = str(dir_subpreg_rbd / f'{estudiante}_{pregunta_selec}_{int(subpreg_selec)}')\n                    agregar_error(queue= queue,\n                                pregunta=preg_error, \n                                error='Subregunta no pudo ser procesada',\n                                nivel_error='Subpregunta', \n                                )\n                    return 'Ups, ocurrio un error en la subpregunta'\n\n\n            except Exception as e:\n                print(e)\n                preg_error = str(dir_subpreg_rbd / f'{estudiante}_{pregunta_selec}')\n                agregar_error(queue= queue, pregunta=preg_error, error='Pregunta no pudo ser procesada', nivel_error='Pregunta')\n                return\n\n        except Exception as e:\n            print('Ocurri\u00f3 un error con la m\u00e1scara')\n            print(e)\n            preg_error = str(dir_subpreg_rbd / f'{estudiante}_{pregunta_selec}')\n            agregar_error(queue= queue, pregunta=preg_error, error='Ocurrio un error con la mascara', nivel_error='Pregunta')\n\n    print('\u00c9xito!')\n</code></pre>"},{"location":"predicciones/","title":"Predicci\u00f3n","text":"<p>En este manual se repasan las funciones asociadas a la predicci\u00f3n de dobles marcas. Aqu\u00ed se reciben las subpreguntas recortadas en el m\u00f3dulo de paralelizaci\u00f3n y se utilizan junto al modelo entrenado previamente. </p>"},{"location":"predicciones/#simce.predicciones.exportar_predicciones","title":"<code>exportar_predicciones(preds, resto_datos, dirs)</code>","text":"<p>Exporta tabla con predicciones a un objeto de tipo parquet.  No retorna nada.</p> <p>Parameters:</p> Name Type Description Default <code>preds</code> <code>DataFrame</code> <p>tabla con predicciones y directorios asociados a las subpreguntas predichas.</p> required <code>resto_datos</code> <code>DataFrame</code> <p>tabla con otros datos asociados a subpreguntas predichas.</p> required <code>dirs</code> <code>list[PathLike]</code> <p>lista de directorios del proyecto.</p> required Source code in <code>simce\\predicciones.py</code> <pre><code>def exportar_predicciones(preds:pd.DataFrame, resto_datos:pd.DataFrame, dirs:list[PathLike]):\n    '''\n    Exporta tabla con predicciones a un objeto de tipo [parquet](https://parquet.apache.org). \n    **No retorna nada**.\n\n    Args:\n        preds: tabla con predicciones y directorios asociados a las subpreguntas predichas.\n\n        resto_datos: tabla con otros datos asociados a subpreguntas predichas.\n\n        dirs: lista de directorios del proyecto. \n\n    '''\n    preds_tot = preds.merge(resto_datos, left_on='dirs', right_on='ruta_imagen_output', how='left')\n    preds_tot.drop(columns=['index', 'dm_sospecha'])\\\n            .sort_values('proba', ascending=False)\\\n            .to_parquet(dirs['dir_predicciones'] / 'predicciones_modelo.parquet')\n</code></pre>"},{"location":"predicciones/#simce.predicciones.obtener_predicciones","title":"<code>obtener_predicciones(loader, device, model)</code>","text":"<p>Obtiene predicciones del modelo.</p> <p>Parameters:</p> Name Type Description Default <code>loader</code> <code>TrainTestDataLoader</code> <p>Data loader que carga datos a predecir.</p> required <code>device</code> <code>device</code> <p>indica si se usa CPU o GPU.</p> required <code>model</code> <code>MaxVit | DataParallel</code> <p>modelo que realizar\u00e1 predicciones.</p> required <p>Returns:</p> Name Type Description <code>predictions</code> <code>list[int]</code> <p>lista de predicciones del modelo (doble marca / falsa sospecha)</p> <code>probs_float</code> <code>list[float]</code> <p>lista de probabilidades asignadas a cada predicci\u00f3n del modelo.</p> <code>lst_directories</code> <code>list[str]</code> <p>lista de directorios asociados a cada predicci\u00f3n.</p> Source code in <code>simce\\predicciones.py</code> <pre><code>def obtener_predicciones(loader:TrainTestDataLoader, device: device,\n                          model:MaxVit|DataParallel)-&gt; tuple[list[int], list[float], list[str]]:\n    '''\n    Obtiene predicciones del modelo.\n\n    Args:\n        loader: Data loader que carga datos a predecir.\n\n        device: indica si se usa CPU o GPU.\n\n        model: modelo que realizar\u00e1 predicciones.\n\n    Returns:\n        predictions: lista de predicciones del modelo (doble marca / falsa sospecha)\n\n        probs_float: lista de probabilidades asignadas a cada predicci\u00f3n del modelo.\n\n        lst_directories: lista de directorios asociados a cada predicci\u00f3n.\n    '''\n    #model_load.eval()\n\n    # Initialize lists to store predictions and true labels\n    predictions = []\n    probs = []\n    lst_directories = []\n\n    with torch.no_grad():\n        # Iterate over the test data\n        for (images, directories) in tqdm(loader):\n            # Move the images and labels to the same device as the model\n            images = images.to(device)\n\n\n            # Make predictions\n\n            outputs = model(images)\n            print(outputs)\n            probabilities = torch.nn.functional.softmax(outputs.data, dim=1)\n            max_probabilities = probabilities.max(dim=1)[0]\n\n            # Get the predicted class for each image\n            _, predicted = torch.max(outputs.data, 1)\n\n            # Store the predictions and true labels\n            predictions.extend(predicted.tolist())\n\n            probs.extend(max_probabilities)\n            lst_directories.extend(directories)\n\n\n    print('Predicciones listas!')\n    probs_float = [i.item() for i in probs]\n\n    return predictions, probs_float, lst_directories\n</code></pre>"},{"location":"predicciones/#simce.predicciones.prepare_model","title":"<code>prepare_model(config, device)</code>","text":"<p>Carga el modelo y realiza preparaciones en torno a esto. Retorna tanto el modelo como el nombre del modelo.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>ConfigParser</code> <p>tabla con predicciones y directorios asociados a las subpreguntas predichas.</p> required <code>device</code> <code>device</code> <p>tabla con otros datos asociados a subpreguntas predichas.</p> required <p>Returns:</p> Name Type Description <code>model</code> <code>MaxVit | DataParallel</code> <p>objeto con el modelo cargado.</p> <code>model_name</code> <code>str</code> <p>nombre del modelo en string.</p> Source code in <code>simce\\predicciones.py</code> <pre><code>def prepare_model(config: ConfigParser, device: device)-&gt; tuple[MaxVit|DataParallel, str]:\n    '''\n    Carga el modelo y realiza preparaciones en torno a esto. Retorna tanto el modelo como el nombre del modelo.\n\n    Args:\n        config: tabla con predicciones y directorios asociados a las subpreguntas predichas.\n\n        device: tabla con otros datos asociados a subpreguntas predichas.\n\n    Returns:\n        model: objeto con el modelo cargado.\n\n        model_name: nombre del modelo en string.\n    '''   \n\n    model  = config.init_obj('arch', models)\n    model_name = config['arch']['type']\n    model = preparar_capas_modelo(model, model_name)\n\n    ruta_modelo = 'modelo_simce.pt'\n    checkpoint = torch.load(ruta_modelo, map_location= device.type)\n    state_dict = checkpoint['state_dict']\n    if config['n_gpu'] &gt; 1:\n        model = torch.nn.DataParallel(model)\n    model.load_state_dict(state_dict)\n\n    model = model.to(device)\n\n    model.eval()\n\n\n\n    return model, model_name\n</code></pre>"},{"location":"proc_imgs/","title":"Recorte de subpreguntas","text":"<p>En este manual se repasan las funciones asociadas al procesamiento de im\u00e1genes que permite un adecuado recorte de subpreguntas.</p> <p>Created on Thu May  2 17:22:37 2024</p> <p>@author: jeconchao</p>"},{"location":"proc_imgs/#simce.proc_imgs.bound_and_crop","title":"<code>bound_and_crop(img, contorno, buffer=0)</code>","text":"<p>Recibe un contorno, obtiene sus coordenadas y las corta desde la imagen ingresada.</p> <p>Parameters:</p> Name Type Description Default <code>img</code> <code>ndarray</code> <p>imagen a recortarle un contorno.</p> required <code>contorno</code> <code>ndarray</code> <p>contorno a recortar de la imagen</p> required <code>buffer</code> <code>int</code> <p>opcionalmente se pueden agregar p\u00edxeles extra en torno al contorno, para obtener una imagen m\u00e1s amplia.</p> <code>0</code> <p>Returns:</p> Name Type Description <code>contorno_recortado</code> <code>ndarray</code> <p>imagen correspondiente al recorte del contorno detectado.</p> Source code in <code>simce\\proc_imgs.py</code> <pre><code>def bound_and_crop(img:np.ndarray, contorno:np.ndarray, buffer:int=0)-&gt;np.ndarray:\n    '''Recibe un contorno, obtiene sus coordenadas y las corta desde la imagen ingresada.\n\n    Args:\n        img: imagen a recortarle un contorno.\n\n        contorno: contorno a recortar de la imagen\n\n        buffer: opcionalmente se pueden agregar p\u00edxeles extra en torno al contorno, para obtener una imagen m\u00e1s amplia.\n\n    Returns:\n        contorno_recortado: imagen correspondiente al recorte del contorno detectado.\n\n    '''\n\n    # Obtengo coordenadas de contorno\n    x, y, w, h = cv2.boundingRect(contorno)\n    # Recorto imagen en base a contorno\n    contorno_recortado = img[max(y-buffer, 0):y+h+buffer, max(0, x-buffer):x+w+buffer]\n    return contorno_recortado\n</code></pre>"},{"location":"proc_imgs/#simce.proc_imgs.crop_and_save_subpreg","title":"<code>crop_and_save_subpreg(img_recuadros_pregunta, lineas_horizontales, i, file_out, verbose)</code>","text":"<p>Recorta subpregunta en base a l\u00edneas horizontales detectadas y luego la exporta. Si esta es m\u00e1s alta que ancha, se le hace un giro de 90 grados, para que sea m\u00e1s ancha que alta. No retorna nada.</p> <p>Parameters:</p> Name Type Description Default <code>img_recuadros_pregunta</code> <code>ndarray</code> <p>imagen con recuadros de una pregunta completa.</p> required <code>lineas_horizontales</code> <code>list[int]</code> <p>lista de l\u00edneas horizontales detectadas</p> required <code>i</code> <code>int</code> <p>elemento correspondiente l\u00ednea horizontal siendo analizada actualmente.</p> required <code>file_out</code> <code>str</code> <p>ruta de la imagen a exportar.     </p> required <code>verbose</code> <code>bool</code> <p>si es True, el c\u00f3digo va a imprimir informaci\u00f3n m\u00e1s completa.</p> required Source code in <code>simce\\proc_imgs.py</code> <pre><code>def crop_and_save_subpreg(img_recuadros_pregunta:np.ndarray, lineas_horizontales:list[int],\n                           i:int, file_out:str, verbose:bool):\n    '''Recorta subpregunta en base a l\u00edneas horizontales detectadas y luego la exporta. Si esta es m\u00e1s alta que ancha,\n    se le hace un giro de 90 grados, para que sea m\u00e1s ancha que alta. **No retorna nada**.\n\n    Args:\n        img_recuadros_pregunta: imagen con recuadros de una pregunta completa.\n\n        lineas_horizontales: lista de l\u00edneas horizontales detectadas\n\n        i: elemento correspondiente l\u00ednea horizontal siendo analizada actualmente.\n\n        file_out: ruta de la imagen a exportar.     \n\n        verbose: si es True, el c\u00f3digo va a imprimir informaci\u00f3n m\u00e1s completa.    \n\n    '''\n\n\n    img_subrptas = img_recuadros_pregunta[lineas_horizontales[i]:\n                                        lineas_horizontales[i+1]]\n    if verbose:\n        print(file_out)\n        print(img_subrptas.shape)\n     # Si la subpregunta es m\u00e1s larga que ancha, la rotamos a lo ancho:\n    if img_subrptas.shape[0] &gt; img_subrptas.shape[1]:\n        img_subrptas = cv2.rotate(img_subrptas, cv2.ROTATE_90_CLOCKWISE)\n\n    # print(file_out)\n    cv2.imwrite(file_out, img_subrptas)\n    if verbose:\n        print(f'{file_out} guardado!')\n</code></pre>"},{"location":"proc_imgs/#simce.proc_imgs.dejar_solo_recuadros_subpregunta","title":"<code>dejar_solo_recuadros_subpregunta(img_pregunta)</code>","text":"<p>Toma imagen recortada de una pregunta completa y vuelve a recortarla, usando m\u00e1scaras de forma que solo queden los recuadros de las respuestas de la pregunta, dejando fuera el texto.</p> <p>Parameters:</p> Name Type Description Default <code>img_pregunta</code> <code>ndarray</code> <p>imagen de una pregunta completa.</p> required <p>Returns:</p> Name Type Description <code>img_recuadros</code> <code>ndarray</code> <p>imagen de recuadros de una pregunta completa</p> Source code in <code>simce\\proc_imgs.py</code> <pre><code>def dejar_solo_recuadros_subpregunta(img_pregunta: np.ndarray)-&gt; np.ndarray:\n    ''' Toma imagen recortada de una pregunta completa y vuelve a recortarla, usando m\u00e1scaras\n        de forma que solo queden los recuadros de las respuestas de la pregunta, dejando fuera el texto.\n\n        Args:\n            img_pregunta: imagen de una pregunta completa.\n\n        Returns:\n            img_recuadros: imagen de recuadros de una pregunta completa\n\n    '''\n    img_pregunta_crop = img_pregunta[60:-30, 30:-30]\n    mask_recuadro = get_mask_imagen(img_pregunta_crop,\n                           lower_color=np.array([0, 0, 224]),\n                           upper_color=np.array([179, 11, 255]),\n                           eliminar_manchas=None, iters=0, revert=False)\n\n    # Si existen columnas blancas, las eliminamos:\n    mean_col = mask_recuadro.mean(axis=0)\n    mask_recuadro[:, np.where(mean_col &gt; 200)] = 0\n    kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (2, 1))\n    mask_dilate = cv2.dilate(mask_recuadro, kernel, iterations=2)\n\n    # Eliminamos manchas verticales y horizontales:\n    lim_vert = mask_recuadro.mean(axis=0).mean()\n    morph_vert = eliminar_o_rellenar_manchas(mask_dilate, orientacion='vertical', \n                                             limite=lim_vert, rellenar=False )\n    lim_hor = mask_recuadro.mean(axis=1).mean()\n    morph_hor = eliminar_o_rellenar_manchas(morph_vert, orientacion='horizontal',\n                                             limite=lim_hor, rellenar=False )\n\n    nonzero = cv2.findNonZero(morph_hor)\n\n    img_recuadros = bound_and_crop(img_pregunta_crop, nonzero, buffer=70)\n\n\n    return img_recuadros\n</code></pre>"},{"location":"proc_imgs/#simce.proc_imgs.eliminar_franjas_negras","title":"<code>eliminar_franjas_negras(img_completa_crop)</code>","text":"<p>Elimina franjas negras que en algunas ocasiones vienen desde el escaneo de las im\u00e1genes. </p> <p>Parameters:</p> Name Type Description Default <code>img_completa_crop</code> <code>ndarray</code> <p>imagen completa del cuadernillo, posterior a operaci\u00f3n de crop exterior. </p> required <p>Returns:</p> Name Type Description <code>img_no_franja</code> <code>ndarray</code> <p>imagen completa del cuadernillo, sin franjas negras, en caso de existir.</p> Source code in <code>simce\\proc_imgs.py</code> <pre><code>def eliminar_franjas_negras(img_completa_crop:np.ndarray)-&gt;np.ndarray:\n    \"\"\"\n    Elimina franjas negras que en algunas ocasiones vienen desde el escaneo de las im\u00e1genes. \n\n    Args:\n        img_completa_crop: imagen completa del cuadernillo, posterior a operaci\u00f3n de crop exterior. \n\n    Returns:\n        img_no_franja: imagen completa del cuadernillo, sin franjas negras, en caso de existir.\n    \"\"\"\n    im2 = get_mask_imagen(img_completa_crop, lower_color=np.array([0, 0, 241]),\n                          upper_color=np.array([179, 255, 255]), iters=2)\n\n    im2[:,:100] = 255\n    im2[:,-100:] = 255\n\n\n    contours = cv2.findContours(\n        im2, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)[0]\n    area_cont = [cv2.contourArea(i) for i in contours]\n    c = contours[area_cont.index(max(area_cont))]\n\n    # Recortamos imagen seg\u00fan lo encontrado en m\u00e1scara\n    img_no_franja = bound_and_crop(img_completa_crop, c)\n\n    return img_no_franja\n</code></pre>"},{"location":"proc_imgs/#simce.proc_imgs.get_contornos_grandes","title":"<code>get_contornos_grandes(mask_deteccion_contornos, limit_area=30000)</code>","text":"<p>Obtiene contornos de preguntas dentro de la p\u00e1gina del cuadernillo. Como el algoritmo tiende a detectar m\u00e1s contornos de los que nos interesan, solo dejamos los contornos grandes.</p> <p>Parameters:</p> Name Type Description Default <code>mask_deteccion_contornos</code> <code>ndarray</code> <p>m\u00e1scara que busca detectar zonas donde debiesen estar contornos. P/e: detecta preguntas en imagen de p\u00e1gina del cuadernillo. </p> required <code>limit_area</code> <code>int</code> <p>\u00e1rea m\u00ednima que debe tener un contorno para que sea considerado</p> <code>30000</code> <p>Returns:</p> Name Type Description <code>big_contours</code> <code>list[ndarray]</code> <p>lista con coordenadas de contornos grandes</p> Source code in <code>simce\\proc_imgs.py</code> <pre><code>def get_contornos_grandes(mask_deteccion_contornos:np.ndarray, limit_area:int=30000)-&gt;list[np.ndarray]:\n    '''\n    Obtiene contornos de preguntas dentro de la p\u00e1gina del cuadernillo. Como el algoritmo tiende a detectar m\u00e1s contornos\n    de los que nos interesan, solo dejamos los contornos grandes.\n\n    Args:\n        mask_deteccion_contornos: m\u00e1scara que busca detectar zonas donde debiesen estar contornos. P/e: detecta preguntas\n            en imagen de p\u00e1gina del cuadernillo. \n\n        limit_area: \u00e1rea m\u00ednima que debe tener un contorno para que sea considerado\n\n    Returns:\n        big_contours: lista con coordenadas de contornos grandes         \n    '''\n\n    # Obtengo contornos\n    contours = cv2.findContours(\n        mask_deteccion_contornos, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)[0]\n    # Me quedo contornos grandes\n    big_contours = [\n        i for i in contours if cv2.contourArea(i) &gt; limit_area]\n\n    big_contours = big_contours[::-1]\n\n    return big_contours\n</code></pre>"},{"location":"proc_imgs/#simce.proc_imgs.get_insumos","title":"<code>get_insumos(tipo_cuadernillo, dir_insumos)</code>","text":"<p>Carga insumos obtenidos en el m\u00f3dulo de generaci\u00f3n de insumos</p> <p>Parameters:</p> Name Type Description Default <code>tipo_cuadernillo</code> <code>str</code> <p>tipo de cuadernillo a revisar: \"estudiantes\" o \"padres\".</p> required <code>dir_insumos</code> <code>PathLike</code> <p>directorio en el que se encuentran datos de insumos.</p> required <p>Returns:</p> Name Type Description <code>insumos_total</code> <code>tuple</code> <p>tupla que contiene cada uno de los insumos, es decir: n_pages, n_preguntas, subpreg_x_preg, dic_cuadernillo, dic_pagina, n_subpreg_tot.</p> Source code in <code>simce\\proc_imgs.py</code> <pre><code>def get_insumos(tipo_cuadernillo:str, dir_insumos:os.PathLike)-&gt; tuple:\n    '''Carga insumos obtenidos en el [m\u00f3dulo de generaci\u00f3n de insumos](../generar_insumos_img)\n\n    Args:\n        tipo_cuadernillo: tipo de cuadernillo a revisar: \"estudiantes\" o \"padres\".\n\n        dir_insumos: directorio en el que se encuentran datos de insumos.\n\n    Returns:\n        insumos_total: tupla que contiene cada uno de los insumos, es decir:\n            n_pages, n_preguntas, subpreg_x_preg, dic_cuadernillo, dic_pagina, n_subpreg_tot.\n\n\n    '''\n    with open(dir_insumos / 'insumos.json') as f:\n        insumos = json.load(f)\n\n    # Seleccionamos insumos para el tipo de cuadernillo que estamos trabajando\n    insumos_usar = insumos[tipo_cuadernillo]\n\n    n_pages = insumos_usar['n_pages']\n    n_preguntas = insumos_usar['n_preguntas']\n    subpreg_x_preg = insumos_usar['subpreg_x_preg']\n    dic_cuadernillo = insumos_usar['dic_cuadernillo']\n    dic_pagina = insumos_usar['dic_pagina']\n    n_subpreg_tot = insumos_usar['n_subpreg_tot']\n\n    insumos_total = n_pages, n_preguntas, subpreg_x_preg, dic_cuadernillo, dic_pagina, n_subpreg_tot\n\n    return insumos_total\n</code></pre>"},{"location":"proc_imgs/#simce.proc_imgs.get_mascara_lineas_horizontales","title":"<code>get_mascara_lineas_horizontales(img_recuadros)</code>","text":"<p>Genera m\u00e1scara que detecta l\u00edneas horizontales que separan subpreguntas, para una imagen de recuadros de una pregunta completa.</p> <p>Parameters:</p> Name Type Description Default <code>img_recuadros</code> <code>ndarray</code> <p>imagen de recuadros de una pregunta completa.</p> required <p>Returns:</p> Name Type Description <code>mask_lineas_horizontales</code> <code>ndarray</code> <p>m\u00e1scara que contiene detecci\u00f3n de l\u00edneas horizontales entre subpreguntas.</p> Source code in <code>simce\\proc_imgs.py</code> <pre><code>def get_mascara_lineas_horizontales(img_recuadros:np.ndarray)-&gt;np.ndarray:\n    ''' Genera m\u00e1scara que detecta l\u00edneas horizontales que separan subpreguntas, para una imagen de recuadros de una pregunta\n    completa.\n\n    Args:\n        img_recuadros: imagen de recuadros de una pregunta completa.\n\n    Returns:\n        mask_lineas_horizontales: m\u00e1scara que contiene detecci\u00f3n de l\u00edneas horizontales entre subpreguntas.\n\n    '''\n\n    px_naranjo = get_mask_imagen(img_recuadros,\n                                   lower_color=np.array(\n                                       [0, 111, 109]),\n                                   upper_color=np.array([18, 255, 255]),\n                                   iters=1, revert=True)\n\n    px_azul = get_mask_imagen(img_recuadros, \n                                   lower_color=np.array([0, 0, 0]),\n                                     upper_color=np.array([114, 255, 255]),\n                                     eliminar_manchas=None, iters=0)\n\n    px_negro = get_mask_imagen(img_recuadros, \n                                lower_color=np.array([0, 0, 204]),\n                                    upper_color=np.array([179, 255, 255]),\n                                    eliminar_manchas=None, iters=0)\n\n    idx_naranjo = np.where(px_naranjo == 0)\n    idx_azul = np.where(px_azul == 0)\n    idx_negro =  np.where(px_negro == 0)\n\n    gray = cv2.cvtColor(img_recuadros, cv2.COLOR_BGR2GRAY)\n    gray[idx_azul ] = 255\n    gray[idx_negro] = 255\n    gray[idx_naranjo ] = 0\n\n    gray2 = gray.copy() \n\n    mean_value = np.mean(gray)    \n    # Replace values above the mean with 255\n    gray2[(gray2 &gt; mean_value*.95) ] = 255\n\n    # Replace values below the mean with 0\n    gray2[(gray2 &lt; mean_value*.95) ] = 0\n\n    gray_limpio = eliminar_o_rellenar_manchas(gray2, \n                                                       orientacion='horizontal',\n                                                         limite=100, rellenar=False)[:-10, :-10]\n\n    kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (2, 1))\n\n    gray_dilated = cv2.dilate(gray_limpio, kernel, iterations=2)\n\n    kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (1, 2))\n\n    gray_dilated2 = cv2.dilate(gray_dilated, kernel, iterations=1)\n\n    kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (3, 3))\n\n    gray_eroded = cv2.erode(gray_dilated2, kernel, iterations=2)\n\n\n    gray_limpio2 = eliminar_o_rellenar_manchas(gray_eroded, \n                                                       orientacion='horizontal',\n                                                         limite=140, rellenar=True)\n\n\n    gray_limpio3 = eliminar_o_rellenar_manchas(gray_limpio2, \n                                                       orientacion='horizontal',\n                                                         limite=220, rellenar=False)\n\n    mask_lineas_horizontales = cv2.bitwise_not(gray_limpio3)\n\n\n\n    return mask_lineas_horizontales\n</code></pre>"},{"location":"proc_imgs/#simce.proc_imgs.get_pages_cuadernillo","title":"<code>get_pages_cuadernillo(pagina_pregunta, n_pages)</code>","text":"<p>Obtiene n\u00famero de p\u00e1gina que se encuentran en la p\u00e1gina izquierda y derecha de la imagen de cuadernillo que se est\u00e1 analizando actualmente.</p> <p>Parameters:</p> Name Type Description Default <code>pagina_pregunta</code> <code>int</code> <p>p\u00e1gina del cuadernillo a la que corresponde la pregunta siendo recortada actualmente.</p> required <code>n_pages</code> <code>int</code> <p>n\u00b0 de p\u00e1ginas total del cuadernillo.</p> required <p>Returns:</p> Name Type Description <code>pages</code> <code>tuple</code> <p>tupla que contiene p\u00e1gina izquierda y derecha del cuadernillo en sus dos elementos, respectivamente</p> Source code in <code>simce\\proc_imgs.py</code> <pre><code>def get_pages_cuadernillo(pagina_pregunta:int, n_pages:int)-&gt;tuple:\n    \"\"\"Obtiene n\u00famero de p\u00e1gina que se encuentran en la p\u00e1gina izquierda y derecha de la imagen de cuadernillo\n    que se est\u00e1 analizando actualmente.\n\n    Args:\n        pagina_pregunta: p\u00e1gina del cuadernillo a la que corresponde la pregunta siendo recortada actualmente.\n\n        n_pages: n\u00b0 de p\u00e1ginas total del cuadernillo.\n\n    Returns:\n        pages: tupla que contiene p\u00e1gina izquierda y derecha del cuadernillo en sus dos elementos, respectivamente\n    \"\"\"\n\n    pages_original = n_pages, 1\n    pages = (pages_original[0] - (pagina_pregunta - 1), pages_original[1] + (pagina_pregunta - 1))\n    if pagina_pregunta % 2 == 0:\n        pages = pages[1], pages[0]\n\n    return pages\n</code></pre>"},{"location":"proc_imgs/#simce.proc_imgs.get_pregunta_inicial_pagina","title":"<code>get_pregunta_inicial_pagina(dic_pagina, pagina_pregunta)</code>","text":"<p>Obtiene la pregunta con la que comienza la p\u00e1gina siendo analizada. Esto se utiliza     para poder \"orientarse\" dentro de la imagen y luego poder extraer la pregunta de     inter\u00e9s.</p> <p>Parameters:</p> Name Type Description Default <code>dic_pagina</code> <code>dict</code> <p>diccionario que indica a qu\u00e9 p\u00e1gina pertenece cada pregunta</p> required <code>pagina_pregunta</code> <code>int</code> <p>p\u00e1gina en la que nos encontramos actualmente</p> required <p>Returns:</p> Name Type Description <code>pregunta_base</code> <code>int</code> <p>n\u00b0 de pregunta en la que parte la p\u00e1gina.</p> Source code in <code>simce\\proc_imgs.py</code> <pre><code>def get_pregunta_inicial_pagina(dic_pagina:dict, pagina_pregunta:int)-&gt;int:\n    '''\n    Obtiene la pregunta con la que comienza la p\u00e1gina siendo analizada. Esto se utiliza\n        para poder \"orientarse\" dentro de la imagen y luego poder extraer la pregunta de\n        inter\u00e9s.\n\n    Args:\n        dic_pagina: diccionario que indica a qu\u00e9 p\u00e1gina pertenece cada pregunta\n\n        pagina_pregunta: p\u00e1gina en la que nos encontramos actualmente\n\n    Returns:\n        pregunta_base: n\u00b0 de pregunta en la que parte la p\u00e1gina.\n    '''\n    if pagina_pregunta != 1 and (pagina_pregunta in dic_pagina.values()):\n        pregunta_base = min([int(re.search(r'\\d+', k).group(0))\n                      for k, v in dic_pagina.items() if v == pagina_pregunta])\n\n    else:  # Para la portada\n        pregunta_base = 0\n\n    return pregunta_base\n</code></pre>"},{"location":"proc_imgs/#simce.proc_imgs.get_subpregs_distintas","title":"<code>get_subpregs_distintas(subpreg_x_preg, dir_subpreg_rbd, estudiante)</code>","text":"<p>Se utiliza cuando el n\u00famero de subpreguntas detectado es distinto al que debiese existir para  la pregunta siendo analizada. Cuando ocurre anota en el excel de problemas en los datos, la serie que  tuvo el problema, en qu\u00e9 pregunta se encontr\u00f3 el problema y cu\u00e1ntas subpreguntas se encontraron y cu\u00e1ntas  deber\u00edan haber habido.</p> <p>Parameters:</p> Name Type Description Default <code>subpreg_x_preg</code> <code>dict</code> <p>diccionario que contiene para cada pregunta, cu\u00e1ntas subpreguntas debiesen existir.</p> required <code>dir_subpreg_rbd</code> <code>PathLike</code> <p>directorio donde se guardan subpreguntas.</p> required <code>estudiante</code> <code>str</code> <p>serie del estudiante que tuvo el problema.</p> required <p>Returns:</p> Name Type Description <code>dic_diferencias</code> <code>dict</code> <p>diccionario que contiene preguntas con diferencias en n\u00b0 de subpreguntas</p> Source code in <code>simce\\proc_imgs.py</code> <pre><code>def get_subpregs_distintas(subpreg_x_preg:dict, dir_subpreg_rbd:os.PathLike, estudiante:str)-&gt;dict:\n    \"\"\"Se utiliza cuando el n\u00famero de subpreguntas detectado es distinto al que debiese existir para\n     la pregunta siendo analizada. Cuando ocurre anota en el excel de problemas en los datos, la serie que\n     tuvo el problema, en qu\u00e9 pregunta se encontr\u00f3 el problema y cu\u00e1ntas subpreguntas se encontraron y cu\u00e1ntas\n     deber\u00edan haber habido.\n\n    Args:\n      subpreg_x_preg: diccionario que contiene para cada pregunta, cu\u00e1ntas subpreguntas debiesen existir.\n\n      dir_subpreg_rbd: directorio donde se guardan subpreguntas.\n\n      estudiante: serie del estudiante que tuvo el problema.\n\n    Returns:\n      dic_diferencias: diccionario que contiene preguntas con diferencias en n\u00b0 de subpreguntas  \"\"\"\n\n    # Creamos un dataframe con una fila por cada imagen de subpregunta asociada al estudiante\n    df = pd.DataFrame(\n        [str(i) for i in dir_subpreg_rbd.iterdir() if estudiante in str(i)], columns=['ruta'])\n\n    # Extraemos pregunta y subpregunta de la ruta y las hacemos columnas:\n    df['preg'] = df.ruta.str.extract(r'p(\\d{1,2})').astype(int)\n    df['subpreg'] = df.ruta.str.extract(r'p(\\d{1,2}_\\d{1,2})')\n\n    # N\u00b0 de subpreguntas por pregunta:\n    df_resumen = pd.DataFrame(df.preg.value_counts().sort_values()\n                              .sort_index().astype(int))\n\n\n    df_resumen.index = 'p'+df_resumen.index.astype('string')\n\n    # Baseline es el n\u00b0 verdadero de subpreguntas por pregunta\n    df_resumen['baseline'] = subpreg_x_preg\n    df_resumen = df_resumen.rename(columns={'count': 'origen'})\n    dic_diferencias = df_resumen[df_resumen['origen'].ne(df_resumen.baseline)].to_dict()\n    return dic_diferencias\n</code></pre>"},{"location":"proc_imgs/#simce.proc_imgs.obtener_lineas_horizontales","title":"<code>obtener_lineas_horizontales(mask_lineas_rellenas, n_pixeles_entre_lineas, threshold=100, minLineLength=200)</code>","text":"<p>Identifica l\u00edneas para obtener puntos en el eje \"y\" para realizar el recorte a subpreguntas.</p> <p>Parameters:</p> Name Type Description Default <code>mask_lineas_rellenas</code> <code>ndarray</code> <p>m\u00e1scara que detecta l\u00edneas horizontales que separan subpreguntas. </p> required <code>n_pixeles_entre_lineas</code> <code>int</code> <p>n\u00b0 de p\u00edxeles m\u00ednimos que tiene que haber entre dos l\u00edneas horizontales.</p> required <code>threshold</code> <code>int</code> <p>par\u00e1metro para detecci\u00f3n de l\u00edneas. Aproximadamente representa cu\u00e1ntos puntos se necesitan para que algo sea detectado como una l\u00ednea</p> <code>100</code> <code>minLineLength</code> <code>int</code> <p>n\u00famero m\u00ednimo de p\u00edxeles para que una l\u00ednea detectada sea efectivamente retornada.</p> <code>200</code> <p>Returns:</p> Name Type Description <code>lines</code> <code>list[int]</code> <p>lista que contiene p\u00edxel vertical al que est\u00e1 asociado cada l\u00ednea.</p> Source code in <code>simce\\proc_imgs.py</code> <pre><code>def obtener_lineas_horizontales(mask_lineas_rellenas:np.ndarray, n_pixeles_entre_lineas:int,\n                                 threshold:int=100,\n                                 minLineLength:int=200)-&gt;list[int]:\n    \"\"\"\n    Identifica l\u00edneas para obtener puntos en el eje \"y\" para realizar el recorte a\n    subpreguntas.\n\n    Args:\n        mask_lineas_rellenas: m\u00e1scara que detecta l\u00edneas horizontales que separan subpreguntas. \n\n        n_pixeles_entre_lineas: n\u00b0 de p\u00edxeles m\u00ednimos que tiene que haber entre dos l\u00edneas horizontales.\n\n        threshold: par\u00e1metro para detecci\u00f3n de l\u00edneas. Aproximadamente representa cu\u00e1ntos puntos se necesitan para que\n            algo sea detectado como una l\u00ednea\n\n        minLineLength: n\u00famero m\u00ednimo de p\u00edxeles para que una l\u00ednea detectada sea efectivamente retornada.\n\n    Returns:\n        lines: lista que contiene p\u00edxel vertical al que est\u00e1 asociado cada l\u00ednea. \n    \"\"\"\n\n\n    # Detectamos l\u00edneas de acuerdo con par\u00e1metros entregados a funci\u00f3n:\n    lines = cv2.HoughLinesP(mask_lineas_rellenas, 1, np.pi/180,\n                            threshold=threshold, minLineLength=minLineLength)\n\n\n\n    if lines is not None:\n\n        indices_ordenados = np.argsort(lines[:, :, 1].flatten())\n        lines_sorted = lines[indices_ordenados]\n\n        puntoy = list(set(chain.from_iterable(lines_sorted[:, :, 1].tolist())))\n        puntoy.append(mask_lineas_rellenas.shape[0])\n        puntoy = sorted(puntoy)\n\n        y = []\n        for i in range(len(puntoy)-1):\n            if puntoy[i+1] - puntoy[i] &lt; n_pixeles_entre_lineas:\n                y.append(i+1)\n\n        # Borramos l\u00edneas muy pegadas entre ellas:\n        for index in sorted(y, reverse=True):\n            del puntoy[index]\n\n        return puntoy\n    else:\n        # Pregunta no cuenta con subpreguntas\n        return None\n</code></pre>"},{"location":"proc_imgs/#simce.proc_imgs.partir_imagen_por_mitad","title":"<code>partir_imagen_por_mitad(img_completa)</code>","text":"<p>Parte una imagen por la mitad. Se ocupa para dividir imagen de cuadernillo en sus dos p\u00e1ginas.</p> <p>Parameters:</p> Name Type Description Default <code>img_completa</code> <code>ndarray</code> <p>imagen completa de 2 p\u00e1ginas del cuadernillo </p> required <p>Returns:</p> Name Type Description <code>imgs_paginas</code> <code>tuple[ndarray]</code> <p>tupla que contiene imagen de p\u00e1gina izquierda y p\u00e1gina derecha del cuadernillo.</p> Source code in <code>simce\\proc_imgs.py</code> <pre><code>def partir_imagen_por_mitad(img_completa:np.ndarray)-&gt;tuple[np.ndarray]:\n    '''Parte una imagen por la mitad. Se ocupa para dividir imagen de cuadernillo\n    en sus dos p\u00e1ginas.\n\n    Args:\n        img_completa: imagen completa de 2 p\u00e1ginas del cuadernillo \n\n    Returns:\n        imgs_paginas: tupla que contiene imagen de p\u00e1gina izquierda y p\u00e1gina derecha del cuadernillo.\n    '''\n    # Buscamos punto medio de imagen para dividirla en las dos\n    # p\u00e1ginas del cuadernillo\n    punto_medio = int(np.round(img_completa.shape[1] / 2, 1))\n\n    img_p1 = img_completa[:, :punto_medio]  # p\u00e1gina izquierda\n    img_p2 = img_completa[:, punto_medio:]  # p\u00e1gina derecha\n\n    imgs_paginas = img_p1, img_p2\n\n    return imgs_paginas\n</code></pre>"},{"location":"proc_imgs/#simce.proc_imgs.recorte_imagen","title":"<code>recorte_imagen(img, x0=110, x1=20, y0=50, y1=50)</code>","text":"<p>Recorta m\u00e1rgenes de las imagenes</p> <p>Parameters:</p> Name Type Description Default <code>img</code> <code>ndarray</code> <p>imagen a ser recortada</p> required <code>x0</code> <code>int</code> <p>D\u00f3nde empieza recorte en eje x. Defaults to 110.</p> <code>110</code> <code>x1</code> <code>int</code> <p>N\u00b0 de pixeles desde x0 hasta finalizar recorte. Defaults to 20.</p> <code>20</code> <code>y0</code> <code>int</code> <p>D\u00f3nde empieza recorte en eje y. Defaults to 50.</p> <code>50</code> <code>y1</code> <code>int</code> <p>N\u00b0 de pixeles desde y0 hasta finalizar recorte. Defaults to 50.</p> <code>50</code> <p>Returns:</p> Name Type Description <code>img_crop</code> <code>ndarray</code> <p>imagen cortada</p> Source code in <code>simce\\proc_imgs.py</code> <pre><code>def recorte_imagen(img:np.ndarray, x0:int=110, x1:int=20, y0:int=50, y1:int=50)-&gt;np.ndarray:\n    \"\"\"Recorta m\u00e1rgenes de las imagenes\n\n    Args:\n        img: imagen a ser recortada\n        x0: D\u00f3nde empieza recorte en eje x. Defaults to 110.\n        x1: N\u00b0 de pixeles desde x0 hasta finalizar recorte. Defaults to 20.\n        y0: D\u00f3nde empieza recorte en eje y. Defaults to 50.\n        y1: N\u00b0 de pixeles desde y0 hasta finalizar recorte. Defaults to 50.\n\n    Returns:\n        img_crop: imagen cortada\n    \"\"\"\n\n    x, y = img.shape[:2]\n    img_crop = img[x0:x-x1, y0:y-y1]\n    return img_crop\n</code></pre>"},{"location":"proc_imgs/#simce.proc_imgs.save_pregunta_completa","title":"<code>save_pregunta_completa(img_recuadros, dir_subpreg_rbd, estudiante, pregunta_selec, args)</code>","text":"<p>Guarda pregunta completa en casos de preguntas que no tienen subpreguntas.     No retorna nada</p> <p>Parameters:</p> Name Type Description Default <code>img_recuadros</code> <code>ndarray</code> <p>imagen de recuadros de una pregunta completa.</p> required <code>dir_subpreg_rbd</code> <code>PathLike</code> <p>directorio donde se guarda im\u00e1genes de subpreguntas y preguntas</p> required <code>estudiante</code> <code>str</code> <p>identificador del estudiante asociado a pregunta</p> required <code>pregunta_selec</code> <code>str</code> <p>pregunta siendo exportada actualmente.</p> required Source code in <code>simce\\proc_imgs.py</code> <pre><code>def save_pregunta_completa(img_recuadros:np.ndarray,\n                            dir_subpreg_rbd:os.PathLike,\n                            estudiante:str, pregunta_selec:str, args:argparse.Namespace):\n    '''Guarda pregunta completa en casos de preguntas que no tienen subpreguntas.\n        **No retorna nada**\n\n    Args:\n        img_recuadros: imagen de recuadros de una pregunta completa.\n\n        dir_subpreg_rbd: directorio donde se guarda im\u00e1genes de subpreguntas y preguntas\n\n        estudiante: identificador del estudiante asociado a pregunta\n\n        pregunta_selec: pregunta siendo exportada actualmente.\n\n\n\n    '''\n    if args.verbose:\n        print('Pregunta no cuenta con subpreguntas, se guardar\u00e1 imagen')\n    file_out = str(\n        dir_subpreg_rbd / f'{estudiante}_{pregunta_selec}.jpg')\n\n    # Si la pregunta es m\u00e1s larga que ancha, la dejamos a lo ancho:\n    if img_recuadros.shape[0] &gt; img_recuadros.shape[1]:\n        img_recuadros = cv2.rotate(img_recuadros, cv2.ROTATE_90_CLOCKWISE)\n\n    #n_subpreg = 1\n    cv2.imwrite(file_out, img_recuadros)\n</code></pre>"},{"location":"proc_tabla_99/","title":"Procesamiento tabla dobles marcas","text":"<p>En este manual se repasan las funciones asociadas a la generaci\u00f3n de la tabla que contiene una fila por cada subpregunta con posible doble marca, desde las tablas Origen presentadas originalmente por la ACE.</p> <p>Created on Thu May  9 17:20:37 2024</p> <p>@author: jeconchao</p>"},{"location":"proc_tabla_99/#simce.proc_tabla_99.get_tablas_99","title":"<code>get_tablas_99(tipo_cuadernillo, directorios, limpiar_ruta)</code>","text":"<p>Genera tabla de dobles marcas para un tipo de cuadernillo espec\u00edfico, donde cada fila es una   subpregunta con sospecha de doble marca. Utiliza insumos generados en    su respectivo m\u00f3dulo para determinar a cu\u00e1l de las    im\u00e1genes pertenece cada subpregunta, lo que posteriormente permite cargar la imagen correcta en     el m\u00f3dulo de paralelizaci\u00f3n. No retorna nada.</p> <p>Parameters:</p> Name Type Description Default <code>tipo_cuadernillo</code> <code>str</code> <p>cuadernillo siendo analizado, puede ser \"estudiantes\" o \"padres\".</p> required <code>directorios</code> <code>list[PathLike]</code> <p>lista de directorios del proyecto.</p> required <code>limpiar_ruta</code> <code>bool</code> <p>booleando que define si la ruta debe limpiarse. En particular, a veces las rutas llegan con la serie del estudiante dentro de esta. En general, el proyecto se realiza de forma que dentro de cada rbd est\u00e1n las im\u00e1genes de todos los estudiantes, por lo que damos la opci\u00f3n de borrar la serie de la ruta.</p> required Source code in <code>simce\\proc_tabla_99.py</code> <pre><code>def get_tablas_99(tipo_cuadernillo:str, directorios:list[PathLike], limpiar_ruta:bool):\n    '''Genera tabla de dobles marcas para un tipo de cuadernillo espec\u00edfico, donde cada fila es una\n      subpregunta con sospecha de doble marca. Utiliza insumos generados en \n      [su respectivo m\u00f3dulo](../generar_insumos_img#simce.generar_insumos_img) para determinar a cu\u00e1l de las\n       im\u00e1genes pertenece cada subpregunta, lo que posteriormente permite cargar la imagen correcta en \n       [el m\u00f3dulo de paralelizaci\u00f3n](../paralelizacion#simce.paralelizacion). **No retorna nada**.\n\n    Args:\n        tipo_cuadernillo: cuadernillo siendo analizado, puede ser \"estudiantes\" o \"padres\".\n        directorios: lista de directorios del proyecto.\n        limpiar_ruta: booleando que define si la ruta debe limpiarse. En particular, a veces las rutas llegan\n            con la serie del estudiante dentro de esta. En general, el proyecto se realiza de forma que dentro\n            de cada rbd est\u00e1n las im\u00e1genes de todos los estudiantes, por lo que damos la opci\u00f3n de borrar\n            la serie de la ruta.\n         '''\n\n\n    nombre_tabla_origen = nombres_tablas_origen[tipo_cuadernillo]\n\n\n    with open(directorios['dir_insumos'] / 'insumos.json') as f:\n        insumos = json.load(f)\n\n    if not tipo_cuadernillo in insumos.keys():\n        print('No hay tabla de padres para este curso')\n        return ''\n    dic_cuadernillo = insumos[tipo_cuadernillo]['dic_cuadernillo']\n\n\n    Origen_DobleMarca = pd.read_csv(directorios['dir_input'] / nombre_tabla_origen,\n                                     delimiter=';', encoding=ENCODING)\n\n\n\n    nombres_col = [i for i in Origen_DobleMarca.columns.to_list() if re.search(r'p\\d+', i)]\n\n    casos_99_origen = procesar_casos_99(Origen_DobleMarca, nombres_col, dic_cuadernillo,\n                                        tipo_cuadernillo)\n\n    casos_99_origen = casos_99_origen.rename(columns={'respuestas': 'dm_sospecha'})\n\n\n    casos_99_origen['rbd_ruta'] = casos_99_origen.ruta_imagen.astype('string').str.extract(regex_extraer_rbd_de_ruta)\n\n    df_final = casos_99_origen.reset_index()\n\n    if limpiar_ruta:\n        df_final.ruta_imagen = df_final.ruta_imagen.str.replace(r'\\\\\\d{7}', '', regex=True, n=1)\n\n    df_final['ruta_imagen_output'] = (directorios['dir_subpreg'] / \n                                      df_final.ruta_imagen.str.replace('\\\\', '/').str.replace('^/', '', regex=True)\n                                      .apply(lambda x: Path(x).parent) /\n                                        (df_final.serie.astype(str) + '_' + df_final.preguntas + '.jpg') )\n\n\n\n    df_final.to_csv(\n        directorios['dir_tabla_99'] / f'casos_99_compilados_{CURSO}_{tipo_cuadernillo}.csv', index=False)\n\n    print('Tabla compilada generada exitosamente!')\n</code></pre>"},{"location":"proc_tabla_99/#simce.proc_tabla_99.get_tablas_99_total","title":"<code>get_tablas_99_total(directorios)</code>","text":"<p>Obtiene y exporta tabla de dobles marcas para estudiantes y padres.     No retorna nada</p> <p>Parameters:</p> Name Type Description Default <code>directorios</code> <code>list[PathLike]</code> <p>lista de directorios del proyecto.</p> required Source code in <code>simce\\proc_tabla_99.py</code> <pre><code>@timing\ndef get_tablas_99_total(directorios:list[PathLike]):\n    '''Obtiene y exporta tabla de dobles marcas para estudiantes y padres.\n        **No retorna nada**\n\n    Args:\n        directorios: lista de directorios del proyecto.'''\n\n    print('Generando tabla estudiantes...')\n\n    get_tablas_99(tipo_cuadernillo='estudiantes', \n                  directorios=directorios, limpiar_ruta=LIMPIAR_RUTA)\n    print('Generando tabla padres...')\n\n    get_tablas_99(tipo_cuadernillo='padres', \n                  directorios=directorios, limpiar_ruta=LIMPIAR_RUTA)\n</code></pre>"},{"location":"proc_tabla_99/#simce.proc_tabla_99.procesar_casos_99","title":"<code>procesar_casos_99(tabla_origen, nombres_col, dic_cuadernillo, tipo_cuadernillo)</code>","text":"<p>Procesa tabla de origen, de forma que cada fila represente una subpregunta con sospecha de doble marca. Adem\u00e1s, identifica a cu\u00e1l imagen corresponde la subpregunta.  </p> <p>Parameters:</p> Name Type Description Default <code>tabla_origen</code> <code>DataFrame</code> <p>tabla Origen proporcionada por ACE. Contiene las respuestas de todos los alumnos que tienen al menos una sospecha de doble marca.</p> required <code>nombres_col</code> <code>list[str]</code> <p>lista de nombres de columnas asociados a preguntas en la tabla de Origen.</p> required <code>dic_cuadernillo</code> <code>dict[str, int]</code> <p>diccionario que indica a qu\u00e9 imagen corresponde cada pregunta del cuadernillo.</p> required <code>tipo_cuadernillo</code> <code>str</code> <p>tipo de cuadernillo siendo analizado, puede ser \"estudiantes\" o \"padres\"</p> required <p>Returns:</p> Name Type Description <code>casos_99_final</code> <code>DataFrame</code> <p>tabla dobles marcas procesada, tal que cada fila represente una subpregunta con sospecha de doble marca</p> Source code in <code>simce\\proc_tabla_99.py</code> <pre><code>def procesar_casos_99(tabla_origen: pd.DataFrame, nombres_col: list[str], dic_cuadernillo: dict[str, int],\n                       tipo_cuadernillo: str)-&gt;pd.DataFrame:\n    '''\n    Procesa tabla de origen, de forma que cada fila represente una subpregunta con sospecha de doble marca.\n    Adem\u00e1s, identifica a cu\u00e1l imagen corresponde la subpregunta.  \n\n    Args:\n        tabla_origen: tabla Origen proporcionada por ACE. Contiene las respuestas de todos los alumnos que tienen\n            al menos una sospecha de doble marca.\n        nombres_col: lista de nombres de columnas asociados a preguntas en la tabla de Origen.\n        dic_cuadernillo: diccionario que indica a qu\u00e9 imagen corresponde cada pregunta del cuadernillo.\n        tipo_cuadernillo: tipo de cuadernillo siendo analizado, puede ser \"estudiantes\" o \"padres\"\n\n    Returns:\n        casos_99_final: tabla dobles marcas procesada, tal que cada fila represente\n            una subpregunta con sospecha de doble marca\n\n\n    '''\n\n    ignorar_p1 = dic_ignorar_p1[tipo_cuadernillo]\n\n    df_melt = tabla_origen.melt(id_vars=variables_identificadoras,\n                            value_vars=nombres_col,\n                            var_name='preguntas',\n                            value_name='respuestas')\n    # Si pregunta 1 debe ser ignorada, la sacamos de la base:\n    if ignorar_p1:\n        df_melt = df_melt[df_melt.preguntas.ne(regex_p1)]\n\n    casos_99 = df_melt[(df_melt['respuestas'] == 99)].copy()\n\n    # Si queremos obtener set de entrenamiento agregamos muestra de respuestas normales:\n\n    # Usamos diccionario cuadernillo para ver a qu\u00e9 imagen est\u00e1 asociada esa pregunta espec\u00edfica:\n    casos_99['ruta_imagen'] = (casos_99.rutaImagen1.str.replace(r'(_\\d+.*)', '_', regex=True) +\n                               casos_99.preguntas.str.extract(r'(p\\d+)').squeeze().map(dic_cuadernillo) +\n                               '.jpg')\n    casos_99_final = casos_99.drop(columns=['rutaImagen1']).set_index(['serie', 'preguntas'])\n\n    return casos_99_final\n</code></pre>"},{"location":"tutorial/","title":"Tutorial de uso","text":"<p>Ac\u00e1 se explica c\u00f3mo correr el modelo y las distintas opciones presentes para los scripts que se hacen cargo de esto.</p>"},{"location":"tutorial/#get_recortespy","title":"get_recortes.py","text":"<p>El primer script se encarga del recorte y sistematizaci\u00f3n de subpreguntas. De acuerdo a lo presentado en el flujo del proyecto, esto considera la etapa de generaci\u00f3n de insumos, procesamiento de la tabla de dobles marcas y selecci\u00f3n y procesamiento de subpreguntas. Durante este proceso se genera la tabla <code>problemas_imagenes.xlsx</code>. Respecto a su uso, este es sencillo, los pasos son los siguientes:</p> <ol> <li> <p>Ubicarse en la ra\u00edz del proyecto. </p> </li> <li> <p>Correr el siguiente comando en la consola:</p> <p><code>python get_recortes.py</code></p> <p>Adem\u00e1s, el script cuenta con dos argumentos opcionales. El primero es <code>--curso</code>, donde se le indica un <code>&lt;id_curso&gt;</code> que corresponde al identificador del curso siendo procesado. Por ejemplo, para cuarto b\u00e1sico, utilizamos:</p> <p><code>python get_recortes.py --curso 4b</code></p> <p>Ojo, el curso tambi\u00e9n puede ser indicado en el script de configuraci\u00f3n, en la variable <code>CURSO</code>. Si el curso se indica en ambos archivos, tomar\u00e1 prioridad el que se indica en la l\u00ednea de comandos. Adem\u00e1s, el script de configuraci\u00f3n maneja las variables m\u00e1s importantes del modelo, por lo que siempre es importante revisarlo y actualizarlo antes de correr este script.</p> <p>En segunda instancia, el c\u00f3digo cuenta con el comando opcional <code>-v</code> o <code>--verbose</code>, que si se agrega, har\u00e1 que se imprima m\u00e1s informaci\u00f3n en la consola respecto al procesamiento de las im\u00e1genes:</p> <p><code>python get_recortes.py -v</code></p> <p>o equivalentemente:</p> <p><code>python get_recortes.py --verbose</code></p> <p>Ojo, el c\u00f3digo puede tomar varias horas en correr. Se imprimir\u00e1 un mensaje en la consola cuando termine el procesamiento, indicando esto mismo.</p> </li> </ol>"},{"location":"tutorial/#get_prediccionespy","title":"get_predicciones.py","text":"<p>El primer script se encarga de la predicci\u00f3n y c\u00e1lculo de indicadores de tinta, como puede verse en el flujo del proyecto. Durante este proceso se genera la tabla <code>predicciones_modelo_final.xlsx</code>. Respecto a su uso, este es sencillo, los pasos son los siguientes:</p> <ol> <li> <p>Ubicarse en la ra\u00edz del proyecto. </p> </li> <li> <p>Correr el siguiente comando en la consola:</p> <p><code>python get_predicciones.py --config &lt;ruta_config_file&gt;</code></p> <p>En este caso, <code>&lt;ruta_config_file&gt;</code> es la ruta al archivo de configuraci\u00f3n del modelo. Por ejemplo:</p> <p><code>python get_predicciones.py --config config/config_pred.json</code></p> <p>En la secci\u00f3n de explicaci\u00f3n del script configuraci\u00f3n se explica en m\u00e1s detalle c\u00f3mo funciona este script.</p> </li> </ol>"},{"location":"utils/","title":"Funciones transversales","text":"<p>En este manual se repasan funciones de una naturaleza m\u00e1s gen\u00e9rica y que, por lo tanto, son utilizadas transversalmente en el repositorio.</p> <p>Created on Tue Apr  9 10:54:35 2024</p> <p>@author: jeconchao</p>"},{"location":"utils/#simce.utils.crear_directorios","title":"<code>crear_directorios(directorios)</code>","text":"<p>Crea los directorios del proyecto. *No retorna nada</p> <p>Parameters:</p> Name Type Description Default <code>directorios</code> <code>list[PathLike]</code> <p>lista que contiene directorios del proyecto.</p> required Source code in <code>simce\\utils.py</code> <pre><code>def crear_directorios(directorios: list[PathLike]):\n    \"\"\"Crea los directorios del proyecto. ***No retorna nada**\n\n    Args:\n        directorios: lista que contiene directorios del proyecto.\n    \"\"\"    \n\n    for k,v  in directorios.items():\n        # No creamos directorio im\u00e1genes brutas, porque ya debieran existir\n        if k != 'dir_img_bruta':\n            v.mkdir(exist_ok=True, parents=True)\n    print('Directorios generados exitosamente!')\n</code></pre>"},{"location":"utils/#simce.utils.eliminar_o_rellenar_manchas","title":"<code>eliminar_o_rellenar_manchas(mask, orientacion, limite, rellenar=False)</code>","text":"<p>Elimina manchas en m\u00e1scaras, volvi\u00e9ndolas m\u00e1s robustas. La diferencia entre rellenar y eliminar es que cuando     rellenamos reemplazamos p\u00edxeles blancos por negros y cuando eliminamos reemplazamos p\u00edxeles negros por blancos.</p> <p>Parameters:</p> Name Type Description Default <code>mask</code> <code>ndarray</code> <p>m\u00e1scara a la que se le reemplazar\u00e1n las manchas.</p> required <code>orientacion</code> <code>str</code> <p>indica si se eliminan manchas a lo largo de columnas (valor \"vertical\") o filas (valor \"horizontal\").</p> required <code>limite</code> <code>int</code> <p>cu\u00e1ntos p\u00edxeles tienen que haber para que sean considerados una mancha.</p> required <code>rellenar</code> <code>bool</code> <p>Indica si vamos a rellenar o eliminar manchas. Default es False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>mask_depurada</code> <code>ndarray</code> <p>m\u00e1scara con las manchas eliminadas/rellenadas.</p> Source code in <code>simce\\utils.py</code> <pre><code>def eliminar_o_rellenar_manchas(mask:np.ndarray, orientacion:str, limite:int, rellenar:bool=False)-&gt;np.ndarray:\n    \"\"\"Elimina manchas en m\u00e1scaras, volvi\u00e9ndolas m\u00e1s robustas. La diferencia entre rellenar y eliminar es que cuando\n        rellenamos reemplazamos p\u00edxeles blancos por negros y cuando eliminamos reemplazamos p\u00edxeles negros por blancos.\n\n    Args:\n        mask: m\u00e1scara a la que se le reemplazar\u00e1n las manchas.\n        orientacion: indica si se eliminan manchas a lo largo de columnas (valor \"vertical\") o filas (valor \"horizontal\").\n        limite: cu\u00e1ntos p\u00edxeles tienen que haber para que sean considerados una mancha.\n        rellenar: Indica si vamos a rellenar o eliminar manchas. Default es False.\n\n    Returns:\n        mask_depurada: m\u00e1scara con las manchas eliminadas/rellenadas.\n    \"\"\"    \n\n    mask_depurada = mask.copy()\n\n    if rellenar:\n        val_replace = 255\n    else:\n        val_replace = 0\n\n\n    if orientacion == 'vertical':\n        axis = 0\n        # Calculamos la media de cada columna\n        mean_col = mask_depurada.mean(axis=axis)\n\n        if rellenar:\n            comparison = mean_col &gt; limite\n        else:\n            comparison = mean_col &lt; limite\n        # Si la media es menor a 100, reemplazamos con 0 (negro):\n        # Esto permite eliminar manchas de color que a veces se dan\n        idx_low_rows = np.where(comparison)[0]\n        mask_depurada[:, idx_low_rows] = val_replace\n    elif orientacion == 'horizontal':\n        axis = 1\n        # Calculamos la media de cada fila:\n        mean_row = mask_depurada.mean(axis=axis)\n\n        if rellenar:\n            comparison = mean_row &gt;= limite\n        else:\n            comparison = mean_row &lt;= limite\n        # Si la media es menor a 100, reemplazamos con 0 (negro):\n        # Esto permite eliminar manchas de color que a veces se dan\n        idx_low_rows = np.where(comparison)[0]\n        mask_depurada[idx_low_rows, :] = val_replace\n    else:\n        return print('Valor inv\u00e1lido para eliminar manchas')\n\n    return mask_depurada\n</code></pre>"},{"location":"utils/#simce.utils.get_mask_imagen","title":"<code>get_mask_imagen(media_img, lower_color=np.array([13, 11, 0]), upper_color=np.array([29, 255, 255]), iters=4, eliminar_manchas='horizontal', revert=False)</code>","text":"<p>Genera una m\u00e1scara binaria para una imagen dada, basada en un rango de color en el espacio de color HSV.</p> <p>Parameters:</p> Name Type Description Default <code>media_img</code> <code>ndarray</code> <p>La imagen de entrada en formato BGR.</p> required <code>lower_color</code> <code>array</code> <p>El l\u00edmite inferior del rango de color en formato HSV. Por defecto es np.array([13, 31, 0]), que corresponde al color naranjo.</p> <code>array([13, 11, 0])</code> <code>upper_color</code> <code>array</code> <p>El l\u00edmite superior del rango de color en formato HSV. Por defecto es np.array([29, 255, 255]),  que corresponde al color naranjo.</p> <code>array([29, 255, 255])</code> <code>iters</code> <code>int</code> <p>n\u00b0 de iteraciones en la dilataci\u00f3n durante la detecci\u00f3n.</p> <code>4</code> <code>eliminar_manchas</code> <code>str</code> <p>indica si se eliminan manchas a lo largo de columnas (valor \"vertical\") o filas (valor \"horizontal\").</p> <code>'horizontal'</code> <code>revert</code> <code>bool</code> <p>si es True, se revierten los colores de la m\u00e1scara.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>mask</code> <code>ndarray</code> <p>Una m\u00e1scara binaria donde los p\u00edxeles de la imagen que est\u00e1n dentro del rango de color especificado son blancos, y todos los dem\u00e1s p\u00edxeles son negros.</p> Source code in <code>simce\\utils.py</code> <pre><code>def get_mask_imagen(media_img: np.ndarray, lower_color:np.array=np.array([13, 11, 0]), upper_color:np.array=np.array([29, 255, 255]),\n                    iters:int=4, eliminar_manchas:str='horizontal', revert:bool=False)-&gt;np.ndarray:\n    \"\"\"\n    Genera una m\u00e1scara binaria para una imagen dada, basada en un rango de color en el espacio de color HSV.\n\n    Args:\n        media_img: La imagen de entrada en formato BGR.\n        lower_color: El l\u00edmite inferior del rango de color en formato HSV.\n            Por defecto es np.array([13, 31, 0]), que corresponde al color naranjo.\n        upper_color: El l\u00edmite superior del rango de color en formato HSV. Por defecto es np.array([29, 255, 255]), \n            que corresponde al color naranjo.\n        iters: n\u00b0 de iteraciones en la dilataci\u00f3n durante la detecci\u00f3n.\n        eliminar_manchas: indica si se eliminan manchas a lo largo de columnas (valor \"vertical\") o filas (valor \"horizontal\").\n        revert: si es True, se revierten los colores de la m\u00e1scara.\n\n    Returns:\n        mask: Una m\u00e1scara binaria donde los p\u00edxeles de la imagen que est\u00e1n dentro del rango de color especificado son blancos,\n            y todos los dem\u00e1s p\u00edxeles son negros.\n    \"\"\"\n    # Convierte la imagen de entrada de BGR a HSV\n    hsv = cv2.cvtColor(media_img, cv2.COLOR_BGR2HSV)\n\n    # Crea una m\u00e1scara binaria donde los p\u00edxeles de la imagen que est\u00e1n dentro del rango de color\n    # especificado son blancos, y todos los dem\u00e1s p\u00edxeles son negros.\n    mask = cv2.inRange(hsv, lower_color, upper_color)\n    kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (3, 3))\n    mask = cv2.dilate(mask, kernel, iterations=iters)\n\n    if eliminar_manchas:\n\n        if eliminar_manchas == 'vertical':\n            mask = eliminar_o_rellenar_manchas(mask, orientacion='vertical', limite=50)\n        elif eliminar_manchas == 'horizontal':\n\n            mask = eliminar_o_rellenar_manchas(mask, orientacion='horizontal', limite=100)\n\n        else:\n            return print('Valor inv\u00e1lido para eliminar manchas')\n    if revert:\n        mask = cv2.bitwise_not(mask)\n\n    return mask\n</code></pre>"},{"location":"utils/#simce.utils.inf_loop","title":"<code>inf_loop(data_loader)</code>","text":"<p>wrapper function for endless data loader.</p> Source code in <code>simce\\utils.py</code> <pre><code>def inf_loop(data_loader):\n    ''' wrapper function for endless data loader. '''\n    for loader in repeat(data_loader):\n        yield from loader\n</code></pre>"},{"location":"utils/#simce.utils.prepare_device","title":"<code>prepare_device(n_gpu_use)</code>","text":"<p>Configura el dispositivo GPU si est\u00e1 disponible. Obtener los \u00edndices de los dispositivos GPU     que se utilizan para DataParallel.</p> <p>Parameters:</p> Name Type Description Default <code>n_gpu_use</code> <code>int</code> <p>cu\u00e1ntas GPUs se especific\u00f3 que ser\u00e1n utilizadas</p> required <p>Returns:     device: indica si se usar\u00e1 CPU o GPU     list_ids: IDs de las GPUs disponibles.</p> Source code in <code>simce\\utils.py</code> <pre><code>def prepare_device(n_gpu_use:int)-&gt;tuple[str,list[int]]:\n    \"\"\"\n     Configura el dispositivo GPU si est\u00e1 disponible. Obtener los \u00edndices de los dispositivos GPU\n        que se utilizan para DataParallel.\n\n    Args:\n        n_gpu_use: cu\u00e1ntas GPUs se especific\u00f3 que ser\u00e1n utilizadas\n    Returns:\n        device: indica si se usar\u00e1 CPU o GPU\n        list_ids: IDs de las GPUs disponibles.\n    \"\"\"\n    n_gpu = torch.cuda.device_count()\n    if n_gpu_use &gt; 0 and n_gpu == 0:\n        print(\"Warning: There\\'s no GPU available on this machine,\"\n              \"training will be performed on CPU.\")\n        n_gpu_use = 0\n    if n_gpu_use &gt; n_gpu:\n        print(f\"Warning: The number of GPU\\'s configured to use is {n_gpu_use}, but only {n_gpu} are \"\n              \"available on this machine.\")\n        n_gpu_use = n_gpu\n    device = torch.device('cuda:0' if n_gpu_use &gt; 0 else 'cpu')\n    list_ids = list(range(n_gpu_use))\n    return device, list_ids\n</code></pre>"}]}